---
title: "Defining the Future of Hematopoiesis: Mmrn1 as a Novel Marker for Long-Term Hematopoietic Stem Cells"
author: "Joseph Womersley"
engine: knitr
execute:
  echo: false
  include: true
  error: false
  message: false
  warning: false
format: html
editor: visual
bibliography: references.bib
csl: vancouver.csl
---

```{=html}
<style>
  body {
    font-family: Arial, sans-serif; /* Sets the overall font family to Arial */
    font-size: 16px; /* Sets the overall font size to 13px */
    text-align: justify; /* Justifies all text within the body */
  }
  
  figure {
    margin-bottom: 0px !important; /* Reduce space below figures */
    overflow: visible !important;
  }
  
  figcaption {
    margin-top: -5px !important; /* Reduce space above captions */
    margin-bottom: 10px !important; /* Increase space below captions */
  }
  
   h1.title { /* Targets the main title of the document */
    text-align: left; /* Aligns the title text to the left */
    font-size: 24px; /* Optional: sets a specific font size for the title */
    margin-top: 0.67em;
    margin-bottom: 0.67em; /* Adjust title margins as needed */
  }
  
  figure, figcaption {
    padding: 0 !important;
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
  }
  
  img, figure {
  max-width: 100% !important;
  width: auto !important;
  height: auto !important;
}

  .dataTables_wrapper {
    font-size: 13px !important; /* Ensure datatable font size is 13px */
    font-family: Arial, sans-serif !important; /* Ensure datatable font is Arial */
  }
</style>
```
```{css}

/* CSS chunk to style the rendered datatable */
.dataTables_wrapper {
  font-size: 13px; /* Adjust the font size as needed */
  font-family: Arial, sans-serif; /* Specify the font family */
}
```

```{r}
#| label: packages
#| include: false
library(tidyverse)
library(patchwork)
library(htmlTable)
library(DT)
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("setdiff", "base")
library(scran)
library(biomaRt)
conflicts_prefer(dplyr::select)
library(bookdown)
library(knitr)
library(kableExtra)
library(ggrepel)
library(pheatmap)
library(plotly)
library(readxl)
conflicts_prefer(plotly::layout)
conflicts_prefer(plotly::slice)

```

```{r}
# first i am loading in my raw data files 
hspc <- read.csv("data_raw/surfaceome_hspc.csv")
prog <- read.csv("data_raw/surfaceome_prog.csv")
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv")

#i am writing as a html to be uploaded to github so a URL can be made so the reader of the html output can see the raw data files 

# Create interactive DT tables for each dataset
dt_prog_raw <- datatable(prog, options = list(pageLength = 10, searchHighlight = TRUE))
dt_hspc_raw <- datatable(hspc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc_raw <- datatable(lthsc, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_prog_raw, "data_raw/HTML/surfaceome_prog.html", selfcontained = TRUE)
saveWidget(dt_hspc_raw, "data_raw/HTML/surfaceome_hspc.html", selfcontained = TRUE)
saveWidget(dt_lthsc_raw, "data_raw/HTML/surfaceome_lthsc.html", selfcontained = TRUE)

# it comes up with a warning for the tables indicating they are too large but when inspecting them, the tables seem to be complete. For larger data sets one will likely not be able to use datatables. 
```

```{r}

# here i am pivoting the expression values so all the counts are in a single column (expr). 
lthsc_long <- lthsc |> 
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expression")

# By pivoting the data we are now able to direct that int a ggplot to create a histogram which allows the datas visualisation to see if there are differences in gene expression across the three cell types. 
lthsc_histogram <- ggplot(lthsc_long, aes(x = expression)) +
  geom_histogram(fill = "green", color = "black", binwidth = 0.5) +
  theme_minimal() + 
  labs(title = "LT.HSC") +
  theme(panel.grid = element_blank(),  # Remove grid lines
        axis.line.x = element_line(color = "black", linewidth = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", linewidth = 1),
        axis.text = element_text(size = 30), 
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2),  # Make axis lines thicker
        plot.title = element_text(size = 40, hjust = 0.5, colour = 'green3', face = "bold"))  # Adjust plot margins to move it downwards slightly

# Save the plot
ggsave("figures/lthsc_histogram.png", plot = lthsc_histogram, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am going the same process but for the hspc raw data 

hspc_long <- hspc |> 
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expression")



hspc_histogram <- ggplot(hspc_long, aes(x = expression)) +
  geom_histogram(fill = "red", color = "black", binwidth = 0.5) +
  theme_minimal() +
  labs(title = "HSPC") +
  theme(panel.grid = element_blank(),  # Remove grid lines
        axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2),  # Make axis lines thicker
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'red', face = "bold"))

# Save the plot
ggsave("figures/hspc_histogram.png", plot = hspc_histogram, width = 10, height = 6, dpi = 300)
```

```{r}
#here i am doing the same thing but for the progenitor raw data

prog_long <- prog |> 
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expression")



prog_histogram <- ggplot(prog_long, aes(x = expression)) +
  geom_histogram(fill = "blue", color = "black", binwidth = 0.5) +
  theme_minimal() +
    labs(title = "Prog") +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30), # Increase axis text size
        axis.title = element_text(size = 35), axis.line = element_line(size = 2), 
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'blue', face = "bold")) + scale_y_continuous(limits = c(0, 114300)) # Adjust y-axis line

# Save the plot
ggsave("figures/prog_histogram.png", plot = prog_histogram, width = 10, height = 6, dpi = 300)
```

```{r}
# here we are determining the min, lowerq, mean, median, sd, upperq, max and n_zero expression of the genes in each cell: 
hspc_summary_samp <- hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))

# so here we are visulaising the data we have collected above by generating a plot that maps the average expression across the cells with them being in order from lowest to highest gene expression and we added in error bars extending from each point to show the range of expression values within that cell, within one standard deviation. 

hspc_point_error_plot <- hspc_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  # Drawing the error bars
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = 0.2,  # Adjust the width of the error bars here
                linewidth = 0.5,  # Adjust the thickness of the error bars here
                color = "red") +  # This sets the color of the error bars 
  # Drawing the points
  geom_point(size = 0.5,  # Adjust the size of the points here
             color = "darkred") +  # This sets the color of the dots independently
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Adjusted for visibility
        axis.title = element_text(size = 35),  # Adjusted for visibility
        axis.line = element_line(size = 2),
        axis.text.x = element_blank(),
  plot.title = element_text(size = 40, hjust = 0.5,  colour = 'red', face = "bold")) +
  labs(x = "Cells reordered", y = "Mean Expression", title = "HSPC")

# Save the plot
ggsave("figures/hspc_point_error_plot.png", plot = hspc_point_error_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the lthsc data set 

lthsc_summary_samp <- lthsc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))


lthsc_point_error_plot <- lthsc_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  # Drawing the error bars
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = 0.2,  # Adjust the width of the error bars here
                linewidth = 0.5,  # Adjust the thickness of the error bars here
                color = "green") +  # This sets the color of the error bars 
  # Drawing the points
  geom_point(size = 1,  # Adjust the size of the points here
             color = "darkgreen") +  # This sets the color of the dots independently
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Adjusted for visibility
        axis.title = element_text(size = 35),  # Adjusted for visibility
        axis.line = element_line(size = 2),
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'green3', face = "bold")) +
  labs(x = "Cells reordered", y = "Mean Expression", title = "LT.HSC")

# Save the plot
ggsave("figures/lthsc_point_error_plot.png", plot = lthsc_point_error_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the lthsc data set 

prog_summary_samp <- prog |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))

prog_point_error_plot <- prog_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  # Drawing the error bars
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = 0.2,  # Adjust the width of the error bars here
                linewidth = 0.5,  # Adjust the thickness of the error bars here
                color = "blue") +  # This sets the color of the error bars to blue
  # Drawing the points
  geom_point(size = 0.5,  # Adjust the size of the points here
             color = "darkblue") +  # This sets the color of the dots independently
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Adjusted for visibility
        axis.title = element_text(size = 35),  # Adjusted for visibility
        axis.line = element_line(size = 2),
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'blue', face = "bold")) +
  labs(x = "Cells reordered", y = "Mean Expression", title = "Prog")

# Save the plot
ggsave("figures/prog_point_error_plot.png", plot = prog_point_error_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# here i am just writing csv files of the data we processed and analysed. 
write_csv(prog_summary_samp, "processed_data/prog_summary_samp.csv")
write_csv(lthsc_summary_samp, "processed_data/lthsc_summary_samp.csv")
write_csv(hspc_summary_samp, "processed_data/hspc_summary_samp.csv")
```

```{r}
# here we are writing the data as a html to be uploaded to github so a URL can be made so the reader of the output can see the file. 

# first we manipulated the daa to become interactive DT tables. 
dt_prog <- datatable(prog_summary_samp, options = list(pageLength = 10, searchHighlight = TRUE))
dt_hspc <- datatable(hspc_summary_samp, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc <- datatable(lthsc_summary_samp, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_prog, "processed_data/HTML/prog_summary_samp.html", selfcontained = TRUE)
saveWidget(dt_hspc, "processed_data/HTML/hspc_summary_samp.html", selfcontained = TRUE)
saveWidget(dt_lthsc, "processed_data/HTML/lthsc_summary_samp.html", selfcontained = TRUE)
```

```{r}
# here we are determining the min, lowerq, mean, median, sd, upperq, max and n_zero expression of the cells in each gene utilising the same technique seen above: 
prog_summary_gene <- prog |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))

# here we are plotting the logged mean counts for each gene in order of size using geom_pointrange() and again ordering the genes from lowest to highest gene expression and we added in error bars extending from each point to show the range of expression values within that gene, within one standard deviation. 

prog_point_error_plot_gene <- prog_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd, color = "blue"),
                  size = 0.1) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd, color = "darkblue"),
                width = 0.1) +
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2), 
        axis.text.x = element_blank(), 
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'blue', face = "bold")) +
  labs(x = "genes", y = "Log Mean Expression", title = "prog") +
  scale_color_identity()

# Save the plot
ggsave("figures/prog_point_error_plot_gene.png", plot = prog_point_error_plot_gene, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the hspc data set 

hspc_summary_gene <- hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))

hspc_point_error_plot_gene <- hspc_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd, color = "red"),
                  size = 0.1) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd, color = "darkred"),
                width = 0.1) +
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2), 
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'red', face = "bold")) +
  labs(x = "genes", y = "Mean Expression", title = "HSPC") +
  scale_color_identity()

# Save the plot
ggsave("figures/hspc_point_error_plot_gene.png", plot = hspc_point_error_plot_gene, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the lthsc data set 
lthsc_summary_gene <- lthsc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))


lthsc_point_error_plot_gene <- lthsc_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd, color = "darkgreen"),
                  size = 0.1) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd, color = "green"),
                width = 0.1) +
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2), 
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'green3', face = "bold")) +
  labs(x = "genes", y = "Mean Expression", title = "LT.HSC") +
  scale_color_identity()

# Save the plot
ggsave("figures/lthsc_point_error_plot_gene.png", plot = lthsc_point_error_plot_gene, width = 10, height = 6, dpi = 300)
```

```{r}
# here i am just writing csv files of the data we processed and analysed.
write_csv(lthsc_summary_gene, "processed_data/lthsc_summary_gene.csv")
write_csv(hspc_summary_gene, "processed_data/hspc_summary_gene.csv")
write_csv(prog_summary_gene, "processed_data/prog_summary_gene.csv")
```

```{r}
# here we are writing the data as a html to be uploaded to github so a URL can be made so the reader of the output can see the file. 

# Create interactive DT tables for each dataset
dt_prog_gene <- datatable(prog_summary_gene, options = list(pageLength = 10, searchHighlight = TRUE))
dt_hspc_gene <- datatable(hspc_summary_gene, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc_gene <- datatable(lthsc_summary_gene, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_prog_gene, "processed_data/HTML/prog_summary_gene.html", selfcontained = TRUE)
saveWidget(dt_hspc_gene, "processed_data/HTML/hspc_summary_gene.html", selfcontained = TRUE)
saveWidget(dt_lthsc_gene, "processed_data/HTML/lthsc_summary_gene.html", selfcontained = TRUE)
```

```{r}
#| include: false
#firstly to perfrom the differential analysis we must ensure that for the gene ids are in the same order in both dataframes:
identical(prog$ensembl_gene_id, hspc$ensembl_gene_id)

# we then combined the two dataframes (minus the gene ids) into one dataframe:
prog_hspc <- bind_cols(prog[-1], hspc[-1])

# next we add back the ensembl_gene_ids as row names, we remvoe and then add them so that there is not two rows of ensembl_gene_ids: 
row.names(prog_hspc) <- prog$ensembl_gene_id

# here we are just creating a vector that indicates which column belongs to which cell type.
cell_type <- rep(c("prog","hspc"), 
                 times = c(length(prog) - 1,
                           length(hspc) - 1))

#then we use this vector and the combined data set to run a differnetial expression analysis:
res_prog_hspc <- findMarkers(prog_hspc, 
                               cell_type)

# findMarkers() is the function that runs the differential expression analysis. 
# The first argument is the dataframe containing the data. The second argument 
# is the vector indicating which columns are in which cell type. 

# The dataframe res_prog_hspc$prog is log prog - log hspc (i.e.,Prog/HSPC). 
# This means - Positive fold change: prog is higher than hspc - 
# Negative fold change: hspc is higher than prog

prog_hspc_results <- data.frame(res_prog_hspc$prog, 
           ensembl_gene_id = row.names(res_prog_hspc$prog))

# Filter for significant genes based on logFC and FDR
# We include genes with logFC > 1 or logFC < -1 and FDR (padj) < 0.05
significant_genes <- prog_hspc_results %>%
  filter((summary.logFC > 1 | summary.logFC < -1) & (FDR < 0.05))

# Calculate the number of significant genes
num_significant_genes <- nrow(significant_genes)

# Output the number of significant genes 
print(num_significant_genes)

# Here we are filtering the results to only show comparisons that are significant:
prog_hspc_results_sig0.01 <- prog_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
#| include: false
# here i am just writing csv files of the data we processed and analysed.
write_csv(prog_hspc, "comparisons/prog_hspc.csv")
write_csv(prog_hspc_results_sig0.01, "results/prog_hspc_results_sig0.01.csv")

```

```{r}
#| include: false
#writing as a html to be uploaded to github so a URL can be made so reader can be shown the data in our render

# Create interactive DT tables for each dataset
dt_prog_hspc <- datatable(prog_hspc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_prog_hspc_results_sig0.01 <- datatable(prog_hspc_results_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_hspc, "comparisons/HTML/prog_hspc.html", selfcontained = TRUE)
saveWidget(dt_prog_hspc_results_sig0.01, "results/HTML/dt_prog_hspc_results_sig0.01.html", selfcontained = TRUE)

```

```{r}
#| include: false
# now we can perfrom the differential analysis on a different comparison; lthsc vs hspc data sets: 
identical(lthsc$ensembl_gene_id, hspc$ensembl_gene_id)

# we then combined the two dataframes (minus the gene ids) into one dataframe:
lthsc_hspc <- bind_cols(lthsc[-1], hspc[-1])

# adding back the ensembl_gene_ids as row names: 
row.names(lthsc_hspc) <- lthsc$ensembl_gene_id

# here we are just creating a vector that indicates which column belongs to which cell type.
cell_type <- rep(c("lthsc","hspc"), 
                 times = c(length(lthsc) - 1,
                           length(hspc) - 1))

#then we use this vector and the combined data set to run a differnetial expression analysis:
res_lthsc_hspc <- findMarkers(lthsc_hspc, 
                             cell_type)


lthsc_hspc_results <- data.frame(res_lthsc_hspc$lthsc, 
           ensembl_gene_id = row.names(res_lthsc_hspc$lthsc))

# Filter for significant genes based on logFC and FDR
# We include genes with logFC > 1 or logFC < -1 and FDR (padj) < 0.05
significant_genes <- lthsc_hspc_results %>%
  filter((summary.logFC > 1 | summary.logFC < -1) & (FDR < 0.05))

# Calculate the number of significant genes
num_significant_genes <- nrow(significant_genes)

# Output the number of significant genes
print(num_significant_genes)


lthsc_hspc_results_sig0.01 <- lthsc_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# again here i am just writing csv files of the data we processed and analysed.
write_csv(lthsc_hspc, "comparisons/lthsc_hspc.csv")
write_csv(lthsc_hspc_results_sig0.01, "results/lthsc_hspc_results_sig0.01.csv")
```

```{r}
#again we are writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in the render

# Create interactive DT tables for each dataset
dt_lthsc_hspc <- datatable(lthsc_hspc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc_hspc_results_sig0.01 <- datatable(lthsc_hspc_results_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_lthsc_hspc, "comparisons/HTML/lthsc_hspc.html", selfcontained = TRUE)
saveWidget(dt_lthsc_hspc_results_sig0.01, "results/HTML/dt_lthsc_hspc_results_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# now we can perfrom the differential analysis on a different comparison; lthsc vs hspc data sets: 
identical(prog$ensembl_gene_id, lthsc$ensembl_gene_id)

# we then combined the two dataframes (minus the gene ids) into one dataframe:
prog_lthsc<- bind_cols(prog[-1], lthsc[-1])

# adding back the ensembl_gene_ids as row names: 
row.names(prog_lthsc) <- prog$ensembl_gene_id

# here we are just creating a vector that indicates which column belongs to which cell type.
cell_type <- rep(c("prog","lthsc"), 
                 times = c(length(prog) - 1,
                           length(lthsc) - 1))

#then we use this vector and the combined data set to run a differnetial expression analysis:
res_prog_lthsc <- findMarkers(prog_lthsc, 
                             cell_type)


prog_lthsc_results <- data.frame(res_prog_lthsc$prog, 
           ensembl_gene_id = row.names(res_prog_lthsc$prog))

# Filter for significant genes based on logFC and FDR
# We include genes with logFC > 1 or logFC < -1 and FDR (padj) < 0.05
significant_genes <- prog_lthsc_results %>%
  filter((summary.logFC > 1 | summary.logFC < -1) & (FDR < 0.05))

# Calculate the number of significant genes
num_significant_genes <- nrow(significant_genes)

# Output the number of significant genes
print(num_significant_genes)

prog_lthsc_results_sig0.01 <- prog_lthsc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# here again i am just writing csv files of the data we processed and analysed.
write_csv(prog_lthsc, "comparisons/prog_lthsc.csv")
write_csv(prog_lthsc_results_sig0.01, "results/prog_lthsc_results_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in the render. 

# Create interactive DT tables for each dataset
dt_prog_lthsc <- datatable(prog_lthsc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_prog_lthsc_results_sig0.01 <- datatable(prog_lthsc_results_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_lthsc, "comparisons/HTML/prog_lthsc.html", selfcontained = TRUE)
saveWidget(dt_prog_lthsc_results_sig0.01, "results/HTML/dt_prog_lthsc_results_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# so we are connecting to the ensembl mouse database using biomart so we can add in gene information including gene names. 

ensembl <- useMart(biomart = "ensembl", 
                   dataset = "mmusculus_gene_ensembl")

# See what information we can retrieve
listAttributes(mart = ensembl) |> head(20)

```

```{r}
#| include: false
# We use the getBM() function to retrieve information from the database. The filters argument is used to specified what kind of identifier we are supplying to retrieve information. The attributes argument is used to select the information we want to retrieve, which in this case is the external gene names for the ensembl_gene_ids that are in our data set. 

gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = prog_hspc_results$ensembl_gene_id,
                   mart = ensembl)

# Notice the dataframe, gene_info, returned only has 279 rows 
# indicating one of the ids does not have information.
# We can find which is missing with:
  
prog_hspc_results |> dplyr::select(ensembl_gene_id) |> 
    filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

# next we can Merge the gene information with the results:

prog_hspc_results <- prog_hspc_results |> 
  left_join(gene_info, by = "ensembl_gene_id")

# Create a dataframe of the genes significant at the 0.01 level:

prog_hspc_results_with_geneinfo_sig0.01 <- prog_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# we are wrting the data frames as csv files here: 
write_csv(prog_hspc_results_with_geneinfo_sig0.01, "results/prog_hspc_results_with_geneinfo_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in our render. 

# Create interactive DT tables for each dataset
dt_prog_hspc_results_with_geneinfo_sig0.01 <- datatable(prog_hspc_results_with_geneinfo_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_hspc_results_with_geneinfo_sig0.01, "results/HTML/dt_prog_hspc_results_with_geneinfo_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# we do the same again for the other comparisions: 

gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = lthsc_hspc_results$ensembl_gene_id,
                   mart = ensembl)

# Notice the dataframe, gene_info, returned only has 279 rows 
# indicating one of the ids does not have information.
# We can find which is missing with:
  
lthsc_hspc_results |> select(ensembl_gene_id) |> 
  filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

# next we can Merge the gene information with the results:

lthsc_hspc_results <- lthsc_hspc_results |> left_join(gene_info, by = "ensembl_gene_id")    

# Create a dataframe of the genes significant at the 0.01 level:

lthsc_hspc_results_with_geneinfo_sig0.01 <- lthsc_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# again writing the a csv file of our results: 
write_csv(lthsc_hspc_results_with_geneinfo_sig0.01, "results/lthsc_hspc_results_with_geneinfo_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in our render:

# Create interactive DT tables for each dataset
dt_lthsc_hspc_results_with_geneinfo_sig0.01 <- datatable(lthsc_hspc_results_with_geneinfo_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_lthsc_hspc_results_with_geneinfo_sig0.01, "results/HTML/dt_lthsc_hspc_results_with_geneinfo_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# we do the same again for the other comparisions: 

gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = prog_lthsc_results$ensembl_gene_id,
                   mart = ensembl)

# Notice the dataframe, gene_info, returned only has 279 rows 
# indicating one of the ids does not have information.
# We can find which is missing with:
  
prog_lthsc_results |> select(ensembl_gene_id) |> 
  filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

# next we can Merge the gene information with the results:

prog_lthsc_results <- prog_lthsc_results |> left_join(gene_info, by = "ensembl_gene_id")   

# Create a dataframe of the genes significant at the 0.01 level:

prog_lthsc_results_with_geneinfo_sig0.01 <- prog_lthsc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# again here i am just writing csv files of the data we processed and analysed.
write_csv(prog_lthsc_results_with_geneinfo_sig0.01, "results/prog_lthsc_results_with_geneinfo_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so. reader can be shown the data in a web browser

# Create interactive DT tables for each dataset
dt_prog_lthsc_results_with_geneinfo_sig0.01 <- datatable(prog_lthsc_results_with_geneinfo_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_lthsc_results_with_geneinfo_sig0.01, "results/HTML/dt_prog_lthsc_results_with_geneinfo_sig0.01.html", selfcontained = TRUE)
```

```{r}
# i have previosuly read in the raw data files but here i am reading them in with the row names being the ensembl_gene_ids. this could be acheived by directly manipulating each data set already read in but this is a very easy way to acheive the same output, but now not all the previous code using the raw data will run unless you read in the data once again where we dont specifcy the row names. 
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
prog <- read.csv("data_raw/surfaceome_prog.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)
```

```{r}
#| include: false
# Add a comparison column to each dataset
prog_lthsc_results_with_geneinfo_sig0.01$comparison <- 'prog_lthsc'
lthsc_hspc_results_with_geneinfo_sig0.01$comparison <- 'lthsc_hspc'
prog_hspc_results_with_geneinfo_sig0.01$comparison <- 'prog_hspc'

# Combine the datasets
combined_results <- bind_rows(prog_lthsc_results_with_geneinfo_sig0.01, lthsc_hspc_results_with_geneinfo_sig0.01, prog_hspc_results_with_geneinfo_sig0.01)

# Calculate the absolute value of summary.logFC for sorting and round to 3sf. This is basically the summary.LogFC but takes away the negative so -1 will turn to 1 so this allows us to rank based on this as high negative and high postive nubmber both correlate to high differential expression: 
combined_results <- combined_results %>%
  dplyr::mutate(abs_summary.logFC = signif(abs(summary.logFC), 4))

# Sort by absolute summary.logFC and FDR (rounded to 3sf), then remove duplicates based on ensembl_gene_id

sorted_combined_results <- combined_results %>%
  dplyr::mutate(FDR_formatted = format(FDR, scientific = TRUE, digits = 4)) %>%
  dplyr::arrange(desc(abs_summary.logFC), FDR) %>%
  dplyr::distinct(ensembl_gene_id, .keep_all = TRUE)


# Calculate the number of genes meeting the specified criteria
significant_genes <- sorted_combined_results %>%
  filter(p.value < 0.05, abs(summary.logFC) > 1)

# Get the count of significant genes
num_significant_genes_no_duplicates <- nrow(significant_genes)

# Get the top 101 unique differentially expressed genes whih are classed as significant and differentially expressed above: 
top_differentially_expressed_genes <- head(sorted_combined_results, 101)

# Select relevant columns and round numerical columns to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::select(p.value, FDR, summary.logFC, external_gene_name, comparison, ensembl_gene_id) %>%
  dplyr::mutate(
    p.value = signif(p.value, 4),
    FDR = signif(FDR, 4),
    summary.logFC = signif(summary.logFC, 4)
  )

# Here i am selecting those 101 genes manually i could have in coded this from our vector, but i encountered many error s when trying to do so, hence this is a work round, but is not very reproducable: 
gene_ids <- c(
"ENSMUSG00000027611",
"ENSMUSG00000054641",
"ENSMUSG00000001946",
"ENSMUSG00000015355",
"ENSMUSG00000016494",
"ENSMUSG00000038235",
"ENSMUSG00000041329",
"ENSMUSG00000024053",
"ENSMUSG00000002808",
"ENSMUSG00000026748",
"ENSMUSG00000030745",
"ENSMUSG00000003420",
"ENSMUSG00000035206",
"ENSMUSG00000036594",
"ENSMUSG00000022816",
"ENSMUSG00000021728",
"ENSMUSG00000025780",
"ENSMUSG00000059588",
"ENSMUSG00000031170",
"ENSMUSG00000028639",
"ENSMUSG00000030117",
"ENSMUSG00000022797",
"ENSMUSG00000053063",
"ENSMUSG00000037405",
"ENSMUSG00000020238",
"ENSMUSG00000025351",
"ENSMUSG00000030336",
"ENSMUSG00000022309",
"ENSMUSG00000030062",
"ENSMUSG00000026581",
"ENSMUSG00000034881",
"ENSMUSG00000005087",
"ENSMUSG00000037649",
"ENSMUSG00000052593",
"ENSMUSG00000026837",
"ENSMUSG00000030830",
"ENSMUSG00000025790",
"ENSMUSG00000026566",
"ENSMUSG00000026072",
"ENSMUSG00000004631",
"ENSMUSG00000028645",
"ENSMUSG00000021427",
"ENSMUSG00000031990",
"ENSMUSG00000079037",
"ENSMUSG00000026395",
"ENSMUSG00000047953",
"ENSMUSG00000027642",
"ENSMUSG00000023942",
"ENSMUSG00000036503",
"ENSMUSG00000027435",
"ENSMUSG00000024462",
"ENSMUSG00000032412",
"ENSMUSG00000002897",
"ENSMUSG00000032336",
"ENSMUSG00000030605",
"ENSMUSG00000026923",
"ENSMUSG00000031934",
"ENSMUSG00000062585",
"ENSMUSG00000028469",
"ENSMUSG00000027408",
"ENSMUSG00000022636",
"ENSMUSG00000026656",
"ENSMUSG00000038280",
"ENSMUSG00000031785",
"ENSMUSG00000027312",
"ENSMUSG00000013236",
"ENSMUSG00000000555",
"ENSMUSG00000004709",
"ENSMUSG00000030748",
"ENSMUSG00000034164",
"ENSMUSG00000028184",
"ENSMUSG00000003379",
"ENSMUSG00000026814",
"ENSMUSG00000004207",
"ENSMUSG00000027366",
"ENSMUSG00000024109",
"ENSMUSG00000068747",
"ENSMUSG00000053062",
"ENSMUSG00000045362",
"ENSMUSG00000024614",
"ENSMUSG00000016496",
"ENSMUSG00000024620",
"ENSMUSG00000023175",
"ENSMUSG00000030124",
"ENSMUSG00000005465",
"ENSMUSG00000074785",
"ENSMUSG00000030754",
"ENSMUSG00000020402",
"ENSMUSG00000032231",
"ENSMUSG00000040528",
"ENSMUSG00000020717",
"ENSMUSG00000022667",
"ENSMUSG00000004609",
"ENSMUSG00000032193",
"ENSMUSG00000037206",
"ENSMUSG00000035498",
"ENSMUSG00000057530",
"ENSMUSG00000021759",
"ENSMUSG00000015316",
"ENSMUSG00000024621",
"ENSMUSG00000040592")




# Create a vector to store the average expression of each gene
average_expression <- numeric(length(gene_ids))

# below i am calculating the average gene expression for each of the cell types and filtering for just those 101 genes. 

# prog --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- prog[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
prog_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  Prog = average_expression
)

# HSPC --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- hspc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
HSPC_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  HSPC = average_expression
)

# LT.HSC ------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- lthsc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
lthsc_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  LT.HSC = average_expression
)

# adding to table ---------------------------------------------------------

# Merge with the average_expression_df for Prog
top_differentially_expressed_genes <- merge(top_differentially_expressed_genes, prog_average_expression_df, by.x = "ensembl_gene_id", by.y = "Ensembl_gene_id", all.x = TRUE)

# Merge with the average_expression_df for Prog
top_differentially_expressed_genes <- merge(top_differentially_expressed_genes, HSPC_average_expression_df, by.x = "ensembl_gene_id", by.y = "Ensembl_gene_id", all.x = TRUE)

# Merge with the average_expression_df for Prog
top_differentially_expressed_genes <- merge(top_differentially_expressed_genes, lthsc_average_expression_df, by.x = "ensembl_gene_id", by.y = "Ensembl_gene_id", all.x = TRUE)

# Order the dataframe based on the absolute values of summary.logFC column
top_differentially_expressed_genes <- top_differentially_expressed_genes[order(abs(top_differentially_expressed_genes$summary.logFC), decreasing = TRUE), ]

#we can now remove the ensembl_gene_id column
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  select(-ensembl_gene_id)

# round the summary.logFC to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(Prog = signif(abs(Prog), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(HSPC = signif(abs(HSPC), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(LT.HSC = signif(abs(LT.HSC), 4))

# rename to ensure is dustingushed from data set wuth duplicates 

top_differentially_expressed_genes_no_duplicates <- top_differentially_expressed_genes


```

```{r}
#| include: false
# now before we calculated the top 101 differentially expressed genes we had filtered out duplicates but it would be an interesting analysis to determine if genes are differentially expressed in more than one comparison. 

# Add a comparison column to each dataset
prog_lthsc_results_with_geneinfo_sig0.01$comparison <- 'prog_lthsc'
lthsc_hspc_results_with_geneinfo_sig0.01$comparison <- 'lthsc_hspc'
prog_hspc_results_with_geneinfo_sig0.01$comparison <- 'prog_hspc'

# Combine the datasets
combined_results <- bind_rows(prog_lthsc_results_with_geneinfo_sig0.01, lthsc_hspc_results_with_geneinfo_sig0.01, prog_hspc_results_with_geneinfo_sig0.01)

# Calculate the absolute value of summary.logFC for sorting and round to 3sf
combined_results <- combined_results %>%
  dplyr::mutate(abs_summary.logFC = signif(abs(summary.logFC), 4))

# Sort by absolute summary.logFC and FDR (rounded to 3sf), then remove duplicates based on ensembl_gene_id
sorted_combined_results <- combined_results %>%
  dplyr::mutate(FDR = signif(FDR, 4)) %>%
  dplyr::arrange(desc(abs_summary.logFC), FDR) 

# Calculate the number of genes meeting the specified criteria
significant_genes <- sorted_combined_results %>%
  filter(p.value < 0.05, abs(summary.logFC) > 1)

# Get the count of significant genes
num_significant_genes_with_duplicates <- nrow(significant_genes)

# Get the top 20 unique differentially expressed genes
top_differentially_expressed_genes <- head(sorted_combined_results, 182)

# Select relevant columns and round numerical columns to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::select(p.value, FDR, summary.logFC, external_gene_name, comparison, ensembl_gene_id) %>%
  dplyr::mutate(
   p.value = sprintf("%.4g", p.value),
    FDR = sprintf("%.4g", FDR),
    summary.logFC = signif(summary.logFC, 4)
  )

# this is the 182 differentilly and significantly expressed genes, again this isnt very reproducable and could have been extracted from the code above isntead of manually creating the vector: 
gene_ids <- c(
"ENSMUSG00000027611",
"ENSMUSG00000054641",
"ENSMUSG00000001946",
"ENSMUSG00000015355",
"ENSMUSG00000016494",
"ENSMUSG00000038235",
"ENSMUSG00000041329",
"ENSMUSG00000041329",
"ENSMUSG00000016494",
"ENSMUSG00000024053",
"ENSMUSG00000024053",
"ENSMUSG00000002808",
"ENSMUSG00000026748",
"ENSMUSG00000030745",
"ENSMUSG00000030745",
"ENSMUSG00000003420",
"ENSMUSG00000002808",
"ENSMUSG00000035206",
"ENSMUSG00000027611",
"ENSMUSG00000036594",
"ENSMUSG00000022816",
"ENSMUSG00000027611",
"ENSMUSG00000021728",
"ENSMUSG00000035206",
"ENSMUSG00000025780",
"ENSMUSG00000059588",
"ENSMUSG00000031170",
"ENSMUSG00000028639",
"ENSMUSG00000030117",
"ENSMUSG00000025780",
"ENSMUSG00000022797",
"ENSMUSG00000053063",
"ENSMUSG00000031170",
"ENSMUSG00000037405",
"ENSMUSG00000020238",
"ENSMUSG00000054641",
"ENSMUSG00000022797",
"ENSMUSG00000025351",
"ENSMUSG00000030336",
"ENSMUSG00000022309",
"ENSMUSG00000022309",
"ENSMUSG00000021728",
"ENSMUSG00000030062",
"ENSMUSG00000026581",
"ENSMUSG00000034881",
"ENSMUSG00000038235",
"ENSMUSG00000015355",
"ENSMUSG00000005087",
"ENSMUSG00000020238",
"ENSMUSG00000037649",
"ENSMUSG00000052593",
"ENSMUSG00000026837",
"ENSMUSG00000030830",
"ENSMUSG00000025790",
"ENSMUSG00000001946",
"ENSMUSG00000054641",
"ENSMUSG00000026566",
"ENSMUSG00000026748",
"ENSMUSG00000001946",
"ENSMUSG00000026072",
"ENSMUSG00000004631",
"ENSMUSG00000028645",
"ENSMUSG00000021427",
"ENSMUSG00000030117",
"ENSMUSG00000030062",
"ENSMUSG00000031990",
"ENSMUSG00000079037",
"ENSMUSG00000026581",
"ENSMUSG00000015355",
"ENSMUSG00000026395",
"ENSMUSG00000047953",
"ENSMUSG00000027642",
"ENSMUSG00000023942",
"ENSMUSG00000030336",
"ENSMUSG00000036503",
"ENSMUSG00000027435",
"ENSMUSG00000024462",
"ENSMUSG00000032412",
"ENSMUSG00000002897",
"ENSMUSG00000032336",
"ENSMUSG00000030605",
"ENSMUSG00000036594",
"ENSMUSG00000026072",
"ENSMUSG00000026923",
"ENSMUSG00000031934",
"ENSMUSG00000062585",
"ENSMUSG00000027435",
"ENSMUSG00000030605",
"ENSMUSG00000028469",
"ENSMUSG00000025790",
"ENSMUSG00000025351",
"ENSMUSG00000027408",
"ENSMUSG00000003420",
"ENSMUSG00000022636",
"ENSMUSG00000028639",
"ENSMUSG00000026656",
"ENSMUSG00000038235",
"ENSMUSG00000062585",
"ENSMUSG00000038280",
"ENSMUSG00000031785",
"ENSMUSG00000027312",
"ENSMUSG00000005087",
"ENSMUSG00000013236",
"ENSMUSG00000047953",
"ENSMUSG00000000555",
"ENSMUSG00000004709",
"ENSMUSG00000026837",
"ENSMUSG00000024462",
"ENSMUSG00000030748",
"ENSMUSG00000053063",
"ENSMUSG00000002897",
"ENSMUSG00000030830",
"ENSMUSG00000034164",
"ENSMUSG00000034164",
"ENSMUSG00000028184",
"ENSMUSG00000003379",
"ENSMUSG00000022816",
"ENSMUSG00000036503",
"ENSMUSG00000032336",
"ENSMUSG00000031785",
"ENSMUSG00000026814",
"ENSMUSG00000004207",
"ENSMUSG00000027366",
"ENSMUSG00000031934",
"ENSMUSG00000021427",
"ENSMUSG00000059588",
"ENSMUSG00000079037",
"ENSMUSG00000024109",
"ENSMUSG00000022636",
"ENSMUSG00000022816",
"ENSMUSG00000037405",
"ENSMUSG00000028184",
"ENSMUSG00000068747",
"ENSMUSG00000034881",
"ENSMUSG00000053062",
"ENSMUSG00000045362",
"ENSMUSG00000024614",
"ENSMUSG00000016496",
"ENSMUSG00000032412",
"ENSMUSG00000004207",
"ENSMUSG00000004631",
"ENSMUSG00000059588",
"ENSMUSG00000003420",
"ENSMUSG00000003379",
"ENSMUSG00000024620",
"ENSMUSG00000023175",
"ENSMUSG00000030124",
"ENSMUSG00000005465",
"ENSMUSG00000074785",
"ENSMUSG00000030754",
"ENSMUSG00000020402",
"ENSMUSG00000027642",
"ENSMUSG00000032231",
"ENSMUSG00000040528",
"ENSMUSG00000020717",
"ENSMUSG00000026566",
"ENSMUSG00000020402",
"ENSMUSG00000022667",
"ENSMUSG00000052593",
"ENSMUSG00000068747",
"ENSMUSG00000024109",
"ENSMUSG00000004609",
"ENSMUSG00000032193",
"ENSMUSG00000037206",
"ENSMUSG00000035498",
"ENSMUSG00000057530",
"ENSMUSG00000027366",
"ENSMUSG00000021759",
"ENSMUSG00000028645",
"ENSMUSG00000037649",
"ENSMUSG00000020717",
"ENSMUSG00000053062",
"ENSMUSG00000026395",
"ENSMUSG00000037405",
"ENSMUSG00000027312",
"ENSMUSG00000026814",
"ENSMUSG00000023175",
"ENSMUSG00000015316",
"ENSMUSG00000024621",
"ENSMUSG00000023942",
"ENSMUSG00000038280",
"ENSMUSG00000040592")


# Create a vector to store the average expression of each gene
average_expression <- numeric(length(gene_ids))

# again we are calculating the average expression and filtering for those 182 genes: 

# prog --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- prog[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
prog_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  Prog = average_expression
)

# HSPC --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- hspc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
HSPC_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  HSPC = average_expression
)

# LT.HSC ------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- lthsc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
lthsc_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  LT.HSC = average_expression
)

# adding to table ---------------------------------------------------------

# Merge with the average_expression_df for Prog
# Add the Prog average expression column
top_differentially_expressed_genes$Prog <- prog_average_expression_df$Prog

# Merge with the average_expression_df for HSPC
top_differentially_expressed_genes$HSPC <- HSPC_average_expression_df$HSPC

# Merge with the average_expression_df for LT.HSC
top_differentially_expressed_genes$LT_HSC <- lthsc_average_expression_df$LT.HSC

# Order the dataframe based on the absolute values of summary.logFC column
top_differentially_expressed_genes <- top_differentially_expressed_genes[order(abs(top_differentially_expressed_genes$summary.logFC), decreasing = TRUE), ]

#we can now remove the ensembl_gene_id column
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  select(-ensembl_gene_id)

# round the summary.logFC to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(Prog = signif(abs(Prog), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(HSPC = signif(abs(HSPC), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(LT_HSC = signif(abs(LT_HSC), 4))

#rename to distingush that there are duplicates

top_differentially_expressed_genes_duplicates <- top_differentially_expressed_genes

```

```{r}
top_differentially_expressed_genes_no_duplicates <- top_differentially_expressed_genes_no_duplicates %>%
  mutate(FDR = sprintf("%.3e", FDR),
         p.value = sprintf("%.3e", p.value))

# again writing the a csv file of our results: 
write_csv(top_differentially_expressed_genes_no_duplicates, "results/top_differentially_expressed_genes_no_duplicates.csv")

#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in our render:

# Create interactive DT tables for each dataset
dt_top_differentially_expressed_genes_no_duplicates <- datatable(top_differentially_expressed_genes_no_duplicates, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_top_differentially_expressed_genes_no_duplicates, "results/HTML/dt_top_differentially_expressed_genes_no_duplicates.html", selfcontained = TRUE)
```

```{r}
top_differentially_expressed_genes_no_duplicates <- top_differentially_expressed_genes_no_duplicates %>%
  mutate(
    FDR = as.numeric(FDR),
    p.value = as.numeric(p.value)
  )

top_differentially_expressed_genes_no_duplicates <- top_differentially_expressed_genes_no_duplicates %>%
  mutate(
    FDR = sprintf("%.3e", FDR),
    p.value = sprintf("%.3e", p.value)
  )

# again writing the a csv file of our results: 
write_csv(top_differentially_expressed_genes_duplicates, "results/top_differentially_expressed_genes_duplicates.csv")

#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in our render:

# Create interactive DT tables for each dataset
dt_top_differentially_expressed_genes_duplicates <- datatable(top_differentially_expressed_genes_duplicates, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_top_differentially_expressed_genes_duplicates, "results/HTML/dt_top_differentially_expressed_genes_duplicates.html", selfcontained = TRUE)
```

```{r}
# we need to read in the raw data again with the row names not the ensembl_gene_id as we are using that column to bind the prog_hspc to the results. This could have been done better in hindsight using a different name for the data when the ensembl_gene_id is the row name. 
hspc <- read.csv("data_raw/surfaceome_hspc.csv")
prog <- read.csv("data_raw/surfaceome_prog.csv")
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv")
```

```{r}
#creating the combined data set with the ensembl_gene_id as the first column and not the column name: 
prog_hspc <- bind_cols(prog, hspc[-1])

#adding the combined data to the results 
prog_hspc_results <- prog_hspc_results |> 
  left_join(prog_hspc, by = "ensembl_gene_id")

# this is ensuring points are coloured if FDR < 0.05 and label points with the external gene name if there summary.LogFC is greater than 2.5. 
prog_hspc_results <- prog_hspc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2.5)   

# Create a data frame for the highlight region
highlight_region <- data.frame(
  xmin = -1.5,
  xmax = 1.5,
  ymin = -Inf,
  ymax = -log10(0.05)
)

# here we are generating a a volcano plot shoing the comparison between progs and hspcs: 

vol_prog_hspc <- ggplot() +
  geom_point(data = prog_hspc_results, aes(x = summary.logFC, y = log10_FDR, colour = interaction(sig, bigfc)), size = 3, alpha = 1) +
  geom_hline(data = prog_hspc_results, aes(yintercept = -log10(0.05)), linetype = "dashed") +
  geom_vline(data = prog_hspc_results, aes(xintercept = 1), linetype = "dashed") +
  geom_vline(data = prog_hspc_results, aes(xintercept = -1), linetype = "dashed") +
  geom_rect(data = highlight_region, aes(xmin = 1, xmax = 3.5, ymin = 0, ymax = 150), fill = "darkblue", alpha = 0.15) +
  geom_rect(data = highlight_region, aes(xmin = -3.2, xmax = -1, ymin = 0, ymax = 150), fill = "red", alpha = 0.15) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", "pink", "deeppink")) +
  geom_text_repel(data = subset(prog_hspc_results, bigfc & sig), aes(x = summary.logFC, y = log10_FDR, label = external_gene_name), size = 5, max.overlaps = 50, vjust = 1.9) +
  theme_classic() +
  theme(legend.position = "none", 
        axis.title = element_text(size = 30), axis.text = element_text(size = 30),
        plot.title = element_text(size = 40, hjust = 0.5),
        plot.margin = margin(t = 30)) +
  ggtitle("Progs vs HSPC")

# Save the plot
ggsave("figures/vol_prog_hspc.png", plot = vol_prog_hspc, width = 10, height = 6, dpi = 300)
```

```{r}

# here we are doing the same for a different comparison.
#creating the combined data set with the ensembl_gene_id as the first column and not the column name: 
prog_lthsc <- bind_cols(prog, lthsc[-1])

#adding the combined data to the results 
prog_lthsc_results <- prog_lthsc_results |> 
  left_join(prog_lthsc, by = "ensembl_gene_id")

# this is ensuring points are coloured if FDR < 0.05 and label points with the external gene name if there summary.LogFC is greater than 2.5. 
prog_lthsc_results <- prog_lthsc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2.5)     

# Create a data frame for the highlight region
highlight_region <- data.frame(
  xmin = -1.5,
  xmax = 1.5,
  ymin = -Inf,
  ymax = -log10(0.05)
)

vol_prog_lthsc <- prog_lthsc_results |> 
  ggplot(aes(x = summary.logFC, 
             y = log10_FDR, 
             colour = interaction(sig, bigfc))) +
  geom_point(size = 3) +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 1, 
             linetype = "dashed") +
  geom_vline(xintercept = -1, 
             linetype = "dashed") +
  geom_rect(data = highlight_region, aes(xmin = 1, xmax = 4, ymin = 0, ymax = 41), fill = "darkblue", alpha = 0.15, inherit.aes = FALSE) +
  geom_rect(data = highlight_region, aes(xmin = -5.5, xmax = -1, ymin = 0, ymax = 41), fill = "green", alpha = 0.15, inherit.aes = FALSE) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray",
                                 "pink",
                                 "deeppink")) +
  geom_text_repel(data = subset(prog_lthsc_results, 
                                bigfc & sig),
                  aes(label = external_gene_name),
                  size = 5,
                  max.overlaps = 50, vjust = 0.9, colour = "black") +
  theme_classic() +
  theme(legend.position = "none", 
        axis.title = element_text(size = 30), axis.text = element_text(size = 30),# Adjust the font size for both x and y axis labels
        plot.title = element_text(size = 40, hjust = 0.5),  # Adjust the title font size and center it
        plot.margin = margin(t = 30)) +  # Add margin at the top for the title
  
  ggtitle("Progs vs LT.HSC")

# Save the plot
ggsave("figures/vol_prog_lthsc.png", plot = vol_prog_lthsc, width = 10, height = 6, dpi = 300)
```

```{r}
#creating the combined data set with the ensembl_gene_id as the first column and not the column name: 
lthsc_hspc <- bind_cols(lthsc, hspc[-1])

#adding the combined data to the results 
lthsc_hspc_results <- lthsc_hspc_results |> 
  left_join(lthsc_hspc, by = "ensembl_gene_id")

# Create a data frame for the highlight region
highlight_region <- data.frame(
  xmin = -1.5,
  xmax = 1.5,
  ymin = -Inf,
  ymax = -log10(0.05)
)

# this is ensuring points are coloured if FDR < 0.05 and label points with the external gene name if there summary.LogFC is greater than 2.5. 
lthsc_hspc_results <- lthsc_hspc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2)

vol_lthsc_hspc <- lthsc_hspc_results |> 
  ggplot(aes(x = summary.logFC, 
             y = log10_FDR, 
             colour = interaction(sig, bigfc))) +
  geom_point(size = 3) +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 1, 
             linetype = "dashed") +
  geom_vline(xintercept = -1, 
             linetype = "dashed") +
  geom_rect(data = highlight_region, aes(xmin = 1, xmax = 3, ymin = 0, ymax = 35), fill = "green", alpha = 0.15, inherit.aes = FALSE) +
  geom_rect(data = highlight_region, aes(xmin = -4, xmax = -1, ymin = 0, ymax = 35), fill = "red", alpha = 0.15, inherit.aes = FALSE) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray",
                                 "pink",
                                 "deeppink")) +
  geom_text_repel(data = subset(lthsc_hspc_results, 
                                bigfc & sig),
                  aes(label = external_gene_name),
                  size = 5,
                  max.overlaps = 50, vjust = 0.5, colour = "black") +
  theme_classic() +
  theme(legend.position = "none", 
        axis.title = element_text(size = 30), axis.text = element_text(size = 30),# Adjust the font size for both x and y axis labels
        plot.title = element_text(size = 40, hjust = 0.5),  # Adjust the title font size and center it
        plot.margin = margin(t = 30)) +  # Add margin at the top for the title
  
  ggtitle("HSPC vs LT.HSC")

# Save the plot
ggsave("figures/vol_lthsc_hspc.png", plot = vol_lthsc_hspc, width = 10, height = 6, dpi = 300)
```

```{r}
# so again i am combining the raw data files based on there ensembl_gene_id: 

# Check if the ensembl_gene_id columns are identical
identical_genes_lthsc_hspc <- identical(lthsc$ensembl_gene_id, hspc$ensembl_gene_id)
identical_genes_lthsc_prog <- identical(lthsc$ensembl_gene_id, prog$ensembl_gene_id)

if (identical_genes_lthsc_hspc && identical_genes_lthsc_prog) {
  # Combine the data frames side by side based on ensembl_gene_id
  combined_data <- bind_cols(lthsc[-1], hspc[-1], prog[-1])
  # Set row names to ensembl_gene_id
  row.names(combined_data) <- lthsc$ensembl_gene_id
} else {
  # Handle the case where ensembl_gene_id columns are not identical
  warning("ensembl_gene_id columns are not identical across data frames.")
  # You may want to explore further or handle this case based on your requirements.
}

# List of genes to filter, these are the top 20 differntailly expressed genes from our differential expression analysis. This can be coded directly by taking the genes from top_20_unique_gene_no_duplicates. 
target_genes <- c(
  "ENSMUSG00000027611", # procr
  "ENSMUSG00000054641", # mmrn1
  "ENSMUSG00000001946", # esam
  "ENSMUSG00000015355", # cd48 
  "ENSMUSG00000016494", # cd34
  "ENSMUSG00000038235", # F11r
  "ENSMUSG00000041329", # Atp1b2
  "ENSMUSG00000024053", # Emilin2
  "ENSMUSG00000002808", # Epdr1
  "ENSMUSG00000026748", # Plxdc2
  "ENSMUSG00000030745", # Il21r
  "ENSMUSG00000003420", # Fcgrt 
  "ENSMUSG00000035206", # Sppl2b
  "ENSMUSG00000036594", # H2-Aa
  "ENSMUSG00000022816", # Fstl1
  "ENSMUSG00000021728", # Emb
  "ENSMUSG00000025780", # Itih5
  "ENSMUSG00000059588", # Calcrl
  "ENSMUSG00000031170", # Slc38a5
  "ENSMUSG00000028639") # Ybx1

# Convert row names to a column and filter
filtered_data <- combined_data %>%
  rownames_to_column(var = "ensembl_gene_id") %>%
  filter(ensembl_gene_id %in% target_genes)

rownames(filtered_data) <- filtered_data$ensembl_gene_id

# Create a mapping between ensembl_gene_id and gene names, we added gene names manually but this could have been done using the BiomaRt to connect with the ensembl data base. 
gene_mapping <- data.frame(
  ensembl_gene_id = c(
  "ENSMUSG00000027611", # procr
  "ENSMUSG00000054641", # mmrn1
  "ENSMUSG00000001946", # esam
  "ENSMUSG00000015355", # cd48 
  "ENSMUSG00000016494", # cd34
  "ENSMUSG00000038235", # F11r
  "ENSMUSG00000041329", # Atp1b2
  "ENSMUSG00000024053", # Emilin2
  "ENSMUSG00000002808", # Epdr1
  "ENSMUSG00000026748", # Plxdc2
  "ENSMUSG00000030745", # Il21r
  "ENSMUSG00000003420", # Fcgrt 
  "ENSMUSG00000035206", # Sppl2b
  "ENSMUSG00000036594", # H2-Aa
  "ENSMUSG00000022816", # Fstl1
  "ENSMUSG00000021728", # Emb
  "ENSMUSG00000025780", # Itih5
  "ENSMUSG00000059588", # Calcrl
  "ENSMUSG00000031170", # Slc38a5
  "ENSMUSG00000028639"),
  gene_name = c(
    "procr", "mmrn1", "esam", "cd48", "cd34", "F11r", "Atp1b2", "Emilin2", "Epdr1", "Plxdc2",
    "Il21r", "Fcgrt", "Sppl2b", "H2-Aa", "Fstl1", "Emb", "Itih5", "Calcrl", "Slc38a5", "Ybx1"
  )
)

# Merge the mapping with the filtered_data to replace ensembl_gene_id with gene names
filtered_data_with_names <- merge(filtered_data, gene_mapping, by = "ensembl_gene_id")

# Set row names to gene names
rownames(filtered_data_with_names) <- filtered_data_with_names$gene_name

# This removes the ensembl_gene_id column and gene name column 
expression_data <- filtered_data_with_names[, 3:ncol(filtered_data_with_names)-1] 

# i want to order the data set based on the summary.LogFC from our differential gene analysis (Table1). firstly i am extracting the current gene names in our expression data. 
current_gene_names <- rownames(expression_data)

#now i am creating a vector for the gene_names i read in, in order. 
ordered_gene_names <- gene_mapping$gene_name

# now i am Finding the intersection of ordered_gene_names with current_gene_names to ensure all names exist
valid_ordered_gene_names <- ordered_gene_names[ordered_gene_names %in% current_gene_names]

# now i am matching and ordering the dataframe rows based on valid_ordered_gene_names. This ensures no NAs are introduced, as we're only using gene names that exist in the current data
order_of_rows <- match(valid_ordered_gene_names, current_gene_names)

# THis actually reorder expression_data based on order_of_rows
expression_data <- expression_data[order_of_rows, ]


# Generate a simple annotation for cell types based on column names
cell_type_annotation <- sapply(colnames(expression_data), function(x) strsplit(x, "_")[[1]][1])
unique_cell_types <- unique(cell_type_annotation)
annotation_df <- data.frame(CellType = factor(cell_type_annotation, levels = unique_cell_types))


```

```{r}
#| include: false

# Generate the heatmap with cell type annotations, note one can chnage the cluster rows and cols to TRUE to gain clustering of the data: 
heatmap_celltypes <- pheatmap(expression_data,
         annotation_col = annotation_df, cellheight = 15, 
         cluster_rows = FALSE, 
         cluster_cols = FALSE,
         fontsize_row = 10, # Increased for bigger Y-axis labels
         fontsize_col = 0, # Set to 0 or use labels_col = FALSE to remove X-axis labels
         labels_col = FALSE, # This will remove the column names from the x-axis
         angle_col = 45, # This might be irrelevant now since we're removing column labels
         color = colorRampPalette(c("blue", "white", "red"))(100),
         legend = TRUE,
         legend_size = 50, # Attempt to increase legend text size; note: 'legend_size' isn't a direct pheatmap argument
         show_rownames = TRUE,
         show_colnames = FALSE # Ensure column names are not shown
)

# Save the plot
ggsave("figures/heatmap_celltypes.png", plot = heatmap_celltypes, width = 10, height = 6, dpi = 300)
```

```{r}
# Load individual datasets. because now we want the ensembl_gene_ids to be the row: 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)

# before we filtered the combined data so we must now generate a new combined data set: 
combined_data <- cbind(prog, hspc, lthsc)

# Transpose the data to have cells in rows and genes in columns: 
combined_data <- t(combined_data)

# Perform PCA:
normalized_data <- scale(combined_data)

pca_result <- prcomp(normalized_data, scale. = TRUE)

# Create a data frame with PCA results:
pca_data <- as.data.frame(pca_result$x)

# Assign cell type information: 
cell_types <- c(rep("Prog", ncol(prog)))
cell_types <- c(cell_types, rep("HSPC", ncol(hspc)))
cell_types <- c(cell_types, rep("LTHSC", ncol(lthsc)))

# # Add the cell_type variable to pca_data --------------------------------
pca_data$cell_type <- cell_types

# Assign a neutral color for baseline expression to all cells
pca_data$Color <- 'grey'  
```

```{r}
#| include: false
#| 
# Define colors for each cell type
cell_type_colors <- c("Prog" = "blue", "HSPC" = "red", "LTHSC" = "green")

# Prepare the initial 3D PCA plot with all cells in grey to represent baseline expression
plot_3d_pca_cell_types <- plot_ly(data = pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
                                  marker = list(color = ~Color, size = 4, opacity = 0.5),  # Use the baseline color
                                  name = "Baseline Expression") %>%
  layout(title = "3D PCA Plot Highlighting Cell Types",
         scene = list(xaxis = list(title = "PC1"),
                      yaxis = list(title = "PC2"),
                      zaxis = list(title = "PC3")),
         legend = list(title = list(text = 'Cell Types'), orientation = "h"))

# Loop over each cell type and overlay their specific colors
for(cell_type in names(cell_type_colors)) {
  cells_of_type <- pca_data$cell_type == cell_type
  plot_3d_pca_cell_types <- plot_3d_pca_cell_types %>%
    add_trace(data = pca_data[cells_of_type, ], x = ~PC1, y = ~PC2, z = ~PC3,
              type = 'scatter3d', mode = 'markers',
              marker = list(color = cell_type_colors[cell_type], size = 4, opacity = 0.8),
              name = cell_type)
}

```

```{r}
#| include: false

# creating a URL using the plotly website

Sys.setenv("plotly_username"="Jwomersley")
Sys.setenv("plotly_api_key"="qQihcRkBSTTX26hk0xlt")

# Ensure you've set your Plotly API credentials as environment variables
response <- plotly::api_create(plot_3d_pca_cell_types, filename = "plot_3d_pca_cell_types")
plot_url <- response$embed_url
print(plot_url)
```

```{r}
#| include: false

# so here we are going to use the pca_data to create a new plot with only the Prog cells highlighted
# This will be used in our panel figure which is further down. 
# Here we are defining Prog as highlighted and anything that isnt Prog as other.
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('Prog'), "Highlighted", "Other")

# Here i am Defining the colors and opacities for the groups.
# We want the Progenitors in blue to stand out and not be covered by the grey other cells:
color_scheme <- c("Highlighted" = "blue", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_Prog <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_Prog <- plot_3d_pca_Prog %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_Prog <- plot_3d_pca_Prog %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "Prog", showlegend = FALSE)
```

```{r}
#| include: false

# so here we are going to use the pca_data to create a new plot with only the Prog cells highlighted
# This will be used in our panel figure which is further down. 
# Here we are defining HSPC as highlighted and anything that isnt Prog as other.
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('HSPC'), "Highlighted", "Other")

# Here i am Defining the colors and opacities for the groups
# We want the HSPC in red to stand out and not be covered by the grey other cells:
color_scheme <- c("Highlighted" = "red", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Creating the 3D PCA plot
plot_3d_pca_HSPC <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_HSPC <- plot_3d_pca_HSPC %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_HSPC <- plot_3d_pca_HSPC %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE), # remove axis labels
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "HSPC", showlegend = FALSE)
```

```{r}
#| include: false

# so here we are going to use the pca_data to create a new plot with only the Prog cells highlighted
# This will be used in our panel figure which is further down. 
# Here we are defining HSPC as highlighted and anything that isnt Prog as other.
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('LTHSC'), "Highlighted", "Other")

# Here i am Defining the colors and opacities for the groups
# We want the LT-HSC in green to stand out and not be covered by the grey other cells:
color_scheme <- c("Highlighted" = "green", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_LT_HSC <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_LT_HSC <- plot_3d_pca_LT_HSC %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_LT_HSC <- plot_3d_pca_LT_HSC %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "LTHSC", showlegend = FALSE)
```

```{r}
#| include: false
# so we are making a 3D PCA where we can see the expression profile of the top 12 differentially expressed genes: 
genes_of_interest <- head(top_differentially_expressed_genes_no_duplicates$external_gene_name, 12)

# Retrieve Ensembl gene IDs based on the external gene names
genes_of_interest <- getBM(attributes = c("external_gene_name", "ensembl_gene_id"),
                    filters = "external_gene_name",
                    values = genes_of_interest,
                    mart = ensembl)
# assigning the colour for our cells with high expression of specfic genes: 
genes_of_interest$Color <- 'red'

 # Expression threshold
  threshold <- 3
  
  # Initialize all cells to be grey, then overlay with colors for high expressions, so we have a baseline expression: 
  pca_data$Color <- 'grey' 
  
  # Prepare the initial 3D PCA plot with all cells in grey
  plot_3d_pca_genes <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
                               marker = list(size = 4, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
                               name = "Baseline Expression") %>% 
    layout(scene = list(aspectmode = "cube"),
         legend = list(title = list(text = 'Gene Expression', font = list(size = 25)),  # Increase the legend title font size
                       orientation = "h", # 'h' for horizontal layout
                       x = 0.5, # Center the legend on the x-axis
                       xanchor = 'center', # Anchor the x-center of the legend
                       y = -0.3, # Position the legend below the x-axis
                       yanchor = 'top', # Anchor the legend at the top
                       font = list(size = 20)))  # Increase font size for legend items


  
  # Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$ensembl_gene_id[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
    # Add trace for high expression of the current gene
    plot_3d_pca_genes <- plot_3d_pca_genes %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$external_gene_name[i],
                marker = list(size = 4, color = genes_of_interest$Color[i], opacity = 0.8),
                showlegend = TRUE)
  }
  
#save as a HTML   
htmlwidgets::saveWidget(plot_3d_pca_genes, "figures/HTML_files/plot_3d_pca_genes.html", selfcontained = TRUE)
```

```{r}
#| include: false

# Ensure you've set your Plotly API credentials as environment variables
response <- plotly::api_create(plot_3d_pca_genes, filename = "plot_3d_pca_genes")
plot_url <- response$embed_url
print(plot_url)
```

```{r}
# define a gene of interest (Procr) 
# using a colour gradient to show the expression of the gene in the cells:

# re-defining the combined data set 
combined_data <- cbind(Prog = prog, HSPC = hspc, LTHSC = lthsc)

#transposing the data set
combined_data <- t(combined_data)

# defining our gene of interest, Procr in this case
gene_of_interest <- 'ENSMUSG00000027611'  

# Identify cells expressing the gene of interest at a high level
gene_expression <- combined_data[, gene_of_interest]  

# Define a color scale for the gene expression gradient
color_scale <- colorRamp(c("white", "purple")) 

# Normalising the gene expression values to use them in the color gradient
normalized_expression <- gene_expression
normalized_expression <- (normalized_expression - min(normalized_expression)) / (max(normalized_expression) - min(normalized_expression))

# Create a data frame including the normalized gene expression
pca_data$Expression <- normalized_expression

plot_3D_PCA_Procr_data <- plot_ly(data = pca_data)

# Update the plot code to incorporate the gene expression colors as a gradient
plot_3D_PCA_Procr <-plot_3D_PCA_Procr_data  %>%
  add_trace(x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', mode = 'markers',
            marker = list(size = 4, color = ~Expression, colorscale = 'Viridis', showscale = TRUE)) %>%
  layout(
    scene = list(
      aspectmode = "cube"),
    title = list(
    text = "Procr",
    x = 0.5,  # Adjust this value to move the title further to the left
    y = 0.95,   # Adjust this value to change the vertical position of the title
    xanchor = "left",  # Anchor the title to the left
    yanchor = "top",   # Anchor the title to the top
    font = list(size = 35, color = "black", weight = "bolder")
  )
)

#save as a HTML   
htmlwidgets::saveWidget(plot_3D_PCA_Procr, "figures/HTML_files/plot_3D_PCA_Procr.html", selfcontained = TRUE)
```

```{r}
#| include: false

# Ensure you've set your Plotly API credentials as environment variables
response <- plotly::api_create(plot_3D_PCA_Procr, filename = "plot_3D_PCA_Procr")
plot_url <- response$embed_url
print(plot_url)
```

```{r}
# define a gene of interest (Mmrn1) 
# using a colour gradient to show the expression of the gene in the cells:


# re-defining the combined data set 
combined_data <- cbind(Prog = prog, HSPC = hspc, LTHSC = lthsc)

#transposing the data set
combined_data <- t(combined_data)

# defining our gene of interest, mmrn1 in this case
gene_of_interest <- 'ENSMUSG00000054641'  

# Filter cells with high expression of the gene of interest in the datasets
threshold_value <- 3.0  

# Identify cells expressing the gene of interest at a high level
gene_expression <- combined_data[, gene_of_interest]  

# Define a color scale for the gene expression gradient
color_scale <- colorRamp(c("white", "purple")) 

# Normalising the gene expression values to use them in the color gradient
normalized_expression <- gene_expression
normalized_expression <- (normalized_expression - min(normalized_expression)) / (max(normalized_expression) - min(normalized_expression))

# Create a data frame including the normalized gene expression
pca_data$Expression <- normalized_expression

plot_3D_PCA_mmrn1_data <- plot_ly(data = pca_data)

# Update the plot code to incorporate the gene expression colors as a gradient
plot_3D_PCA_mmrn1 <- plot_3D_PCA_mmrn1_data %>%
  add_trace(x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', mode = 'markers',
            marker = list(size = 4, color = ~Expression, colorscale = 'Viridis', showscale = TRUE)) %>%
  layout(
    scene = list(
      aspectmode = "cube"),
    title = list(
    text = "Mmrn1",
    x = 0.5,  # Adjust this value to move the title further to the left
    y = 0.95,   # Adjust this value to change the vertical position of the title
    xanchor = "left",  # Anchor the title to the left
    yanchor = "top",   # Anchor the title to the top
    font = list(size = 35, color = "black", weight = "bolder")
  )
)

#save as a HTML   
htmlwidgets::saveWidget(plot_3D_PCA_mmrn1, "figures/HTML_files/plot_3D_PCA_mmrn1.html", selfcontained = TRUE)
```

```{r}
#| include: false

# Ensure you've set your Plotly API credentials as environment variables
response <- plotly::api_create(plot_3D_PCA_mmrn1, filename = "plot_3D_PCA_mmrn1")
plot_url <- response$embed_url
print(plot_url)
```

```{r}
# Bar graph showing average Mmrn1 expression across the three cell types

# Function to calculate standard error
calc_se <- function(x) {
  sd_x <- sd(x)
  n_x <- length(x)
  se_x <- sd_x / sqrt(n_x)
  return(se_x)
}

# Function to generate summary statistics for a gene
summary_data_mmrn1 <- function(mmrn1, lthsc, hspc, prog) {
  # Extract gene values using row names
  gene_vals_lthsc <- as.numeric(lthsc[rownames(lthsc) == mmrn1, ])
  gene_vals_hspc <- as.numeric(hspc[rownames(hspc) == mmrn1, ])
  gene_vals_prog <- as.numeric(prog[rownames(prog) == mmrn1, ])

  # Remove NA values
  gene_vals_lthsc <- gene_vals_lthsc[!is.na(gene_vals_lthsc)]
  gene_vals_hspc <- gene_vals_hspc[!is.na(gene_vals_hspc)]
  gene_vals_prog <- gene_vals_prog[!is.na(gene_vals_prog)]

  # Calculate summary statistics
  summary_stats <- data.frame(
    cell_type = c("LT.HSC", "HSPC", "Prog"),
    mean = c(mean(gene_vals_lthsc), mean(gene_vals_hspc), mean(gene_vals_prog)),
    std = c(sd(gene_vals_lthsc), sd(gene_vals_hspc), sd(gene_vals_prog)),
    n = c(length(gene_vals_lthsc), length(gene_vals_hspc), length(gene_vals_prog))
  )

  # Calculate standard error
  summary_stats$se <- sapply(list(gene_vals_lthsc, gene_vals_hspc, gene_vals_prog), calc_se)

  return(summary_stats)
}

# defining our gene of interest 
mmrn1 <- "ENSMUSG00000054641"

# Generate summary statistics for the specified gene ID
gene_summary <- summary_data_mmrn1(mmrn1, lthsc, hspc, prog)

# Define the order of cell types
cell_type_order <- c("LT.HSC", "HSPC", "Prog")

# Convert cell_type to factor with the specified order
gene_summary$cell_type <- factor(gene_summary$cell_type, levels = cell_type_order)

```

```{r}
# Extract Mmrn1 expression data for each cell type and combine into a single data frame for
# statistical analysis
mmrn1_lthsc <- as.numeric(lthsc["ENSMUSG00000054641", ])
mmrn1_hspc <- as.numeric(hspc["ENSMUSG00000054641", ])
mmrn1_prog <- as.numeric(prog["ENSMUSG00000054641", ])

# Combine into a single data frame with appropriate labels
mmrn1_data <- data.frame(
  expression = c(mmrn1_lthsc, mmrn1_hspc, mmrn1_prog),
  cell_type = factor(rep(c("LT.HSC", "HSPC", "Prog"), 
                         times = c(length(mmrn1_lthsc), length(mmrn1_hspc), length(mmrn1_prog))))
)

# conduct an anova test
anova_result <- aov(expression ~ cell_type, data = mmrn1_data)

# conduct a turkey test to see P.values for the comparisons 
tukey_result <- TukeyHSD(anova_result)

# Extract the results into a data frame for easier manipulation
tukey_df <- as.data.frame(tukey_result$cell_type)

# Format and print the adjusted p-values with increased precision, so we can see the exact P.values
tukey_df$p.adj.formatted <- formatC(tukey_df$`p adj`, format = "f", digits = 40)

```

```{r}
#| include: false

Mmrn1_expression_plot <- ggplot(gene_summary, aes(x = cell_type, y = mean)) + geom_bar(aes(x = cell_type, y = mean, fill = cell_type), stat = "identity", width = 0.6) + 
  geom_point(position = position_dodge(width = 0.5), size = 1.5) +  # Add points for means
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.1, position = position_dodge(width = 0.5), size = 0.5) +  # Error bars
  labs(
    y = "Gene expression",
    title = "A)",
    subtitle = "Expression of Mmrn1 across cell types"
  ) +
  scale_fill_manual(values = c("green", "red", "blue")) +  # Set different colors for the bars
  theme_classic() +
  theme(plot.title = element_text(hjust = 0, vjust = 1, size = 45, face = "bold"),
    axis.title.x = element_text(size = 0), # we dont need an X title, but we have left it in if your data need one and for easy manipulation
    axis.title.y = element_text(size = 25), # Bigger and bolder Y axis title
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 20), # Bigger X axis labels
    axis.text.y = element_text(size = 22), # Bigger Y axis labels
    plot.subtitle = element_text(size = 22, hjust = 0.5, vjust = 1),
    legend.title = element_text(size = 20), legend.text = element_text(size = 17)) + annotate("text", x = 1, y = 5.6 , label = "5.035", size = 6) +
  annotate("text", x = 2, y = 3.25, label = "2.840", size = 6) +
  annotate("text", x = 3, y = 1.25, label = "0.891", size = 6) + 
  annotate("text", x = 1.5, y = 6.3 , label = "****", size = 7) +
  annotate("text", x = 2, y = 7.3, label = "****", size = 7) +
  annotate("text", x = 2.5, y = 6.8, label = "****", size = 7)+
  annotate("segment", x = 1, xend = 3, y = 7.3, yend = 7.3, colour = "black", size = 0.5) + 
  annotate("segment", x = 1, xend = 1, y = 7.3, yend = 7, colour = "black", size = 0.5) + 
  annotate("segment", x = 3, xend = 3, y = 7.3, yend = 7, colour = "black", size = 0.5) + 
  annotate("segment", x = 1, xend = 2, y = 6.3, yend = 6.3, colour = "black", size = 0.5) +
  annotate("segment", x = 1, xend = 1, y = 6.3, yend = 6, colour = "black", size = 0.5) + 
  annotate("segment", x = 2, xend = 2, y = 6.3, yend = 6, colour = "black", size = 0.5)  +
  annotate("segment", x = 2, xend = 3, y = 6.8, yend = 6.8, colour = "black", size = 0.5) +  
  annotate("segment", x = 2, xend = 2, y = 6.8, yend = 6.5, colour = "black", size = 0.5) + 
  annotate("segment", x = 3, xend = 3, y = 6.8, yend = 6.5, colour = "black", size = 0.5)  

# Save the plot
ggsave("figures/Mmrn1_expression_plot.png", plot = Mmrn1_expression_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# writing in the sub-population data
er_cell_types <- read.csv("sub_population_data/er_cell_types.csv")

# writing as a html to be uploaded to github so a URL can be made
# Create interactive DT tables for each dataset
dt_er_cell_types <- datatable(er_cell_types, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_er_cell_types , "sub_population_data/HTML/dt_er_cell_types.html", selfcontained = TRUE)

```

```{r}
# Average expression of mmrn1 across the sub-population cell types: 

# combining the raw data again: 
 combined_data <- bind_cols(lthsc, hspc, prog)
 
# Create a new data frame with the row names as the first column
combined_data <- data.frame(ensembl_gene_id = rownames(combined_data), combined_data)

# Reset the row names of the new data frame to NULL (optional)
rownames(combined_data) <- NULL

# Prepare the er_cell_types dataframe for easier merging
# Assuming we want to map each cell to its most specific non-zero sub-type
er_cell_types_long <- pivot_longer(er_cell_types, cols = -cell, names_to = "cell_type", values_to = "value") %>%
  filter(value == 1) %>%
  select(-value)

# Function to prioritize cell types
prioritize_cell_type <- function(cell_type) {
  priority_rank <- case_when(
    grepl("LTHSC$", cell_type) & !grepl("_broad", cell_type) ~ 1,
    grepl("^MPP$", cell_type) ~ 2,
    grepl("MPP[0-9]$", cell_type) ~ 3,
    grepl("STHSC$", cell_type) & !grepl("_broad", cell_type) ~ 4,
    TRUE ~ 5  # Default priority for unspecified types or broad types
  )
  return(priority_rank)
}

# Apply prioritization logic
er_cell_types_long_prioritised <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)  # Remove the priority rank column after sorting

# Filter for the specific gene 'ENSMUSG00000054641'
gene_expression <- combined_data %>%
  filter(ensembl_gene_id == 'ENSMUSG00000054641') %>%
  select(-ensembl_gene_id) %>%
  t() %>%
  as.data.frame()

# Name the columns appropriately
colnames(gene_expression) <- 'ENSMUSG00000054641'
gene_expression$cell <- rownames(gene_expression)

# Merge with the main data frame
er_cell_types_long_prioritised <- er_cell_types_long_prioritised %>%
  left_join(gene_expression, by = "cell")

# Create the 'new_cell' column which is just the cells but removing the numberical identifyer by taking the unique cell naming and removing the numbering: 
er_cell_types_long_prioritised$new_cell <- paste(er_cell_types_long_prioritised$cell_type, sub(".*_(\\d+)$", "\\1", er_cell_types_long_prioritised$cell), sep = "_")

# Filter out cell types ending with '_broad', ESLAM, HSC1 and projected cells: 
filtered_er_cell_types_long_prioritised <- er_cell_types_long_prioritised %>%
  filter(
    !grepl('_broad$', cell_type),
    !grepl('ESLAM', cell_type),
    !grepl('HSC1', cell_type),
    !grepl('Projected', cell_type)
  )

# Calculate mean and SEM for each cell type, excluding '_broad'
average_expression_with_sem_filtered <- filtered_er_cell_types_long_prioritised %>%
  group_by(cell_type) %>%
  summarise(Average_Expression = mean(ENSMUSG00000054641, na.rm = TRUE),
            SEM = sd(ENSMUSG00000054641, na.rm = TRUE) / sqrt(n()))


```

```{r}
#| include: false

# Plotting with error bars and customized theme
Mmrn1_subpop_plot <- ggplot(average_expression_with_sem_filtered, aes(x = cell_type, y = Average_Expression, fill = cell_type)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("purple", "darkgreen", "lightblue", "green", "orange", "red")) +  
  geom_errorbar(aes(ymin = Average_Expression - SEM, ymax = Average_Expression + SEM), width = .2) +
  theme_minimal() +
  theme(
    plot.background = element_blank(), # Remove background
    panel.background = element_blank(), # Remove panel background
    panel.grid.major = element_blank(), # Remove major grid lines
    panel.grid.minor = element_blank(), # Remove minor grid lines
    axis.line = element_line(color = "black"), # Strong lines for X and Y axis
    axis.title.x = element_text(size = 0), # we dont need an X title, but we have left it in if your data need one and for easy manipulation
    axis.title.y = element_text(size = 20), # Bigger and bolder Y axis title
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 16), # Bigger X axis labels
    axis.text.y = element_text(size = 22), # Bigger Y axis labels
   plot.title = element_text(hjust = 0, vjust = 1, size = 45, face = "bold"), # Bigger and bolder plot title
   plot.subtitle = element_text(size = 20, hjust = 0.5, vjust = 1), # Bigger plot subtitle
    legend.title = element_text(size = 20), # Corrected legend title size
    legend.text = element_text(size = 17) # Corrected legend text size
  ) +
  labs(x = "Cell Type", y = "Average Expression", title = "B)", subtitle = "Expression of Mmrn1 Across Sub-populations") +
  scale_y_continuous(limits = c(NA, 8)) + 
  annotate("segment", x = 1, xend = 4, y = 8, yend = 8, colour = "black", size = .5) + 
  annotate("segment", x = 4, xend = 2, y = 6.5, yend = 6.5, colour = "black", size = .5) +
  annotate("segment", x = 4, xend = 3, y = 7.0, yend = 7.0, colour = "black", size = .5) +  
  annotate("segment", x = 4, xend = 6, y = 7.5, yend = 7.5, colour = "black", size = .5) +  
  annotate("segment", x = 4, xend = 5, y = 6, yend = 6, colour = "black", size = .5) +   
  annotate("text", x = 2.5, y = 8, label = "****", size = 6) +
  annotate("text", x = 5, y = 7.5, label = "****", size = 6) +
  annotate("text", x = 3.5, y = 7, label = "****", size = 6) +
  annotate("text", x = 3, y = 6.5, label = "****", size = 6) +
  annotate("text", x = 4.5, y = 6, label = "****", size = 6) +
  annotate("text", x = 1, y = 1.4, label = "1.016", size = 5) +
  annotate("text", x = 2, y = 1.1, label = "0.668", size = 5) + 
  annotate("text", x = 3, y = 2.05, label = "1.635", size = 5) +
  annotate("text", x = 4, y = 5.6, label = "5.149", size = 5) +
  annotate("text", x = 5, y = 1, label = "0.651", size = 5) +
  annotate("text", x = 6, y = 3.6, label = "3.102", size = 5)

# Save the plot
ggsave("figures/Mmrn1_subpop_plot.png", plot = Mmrn1_subpop_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# Editing prioritisation logic to see mmrn1 expression across the MPP sub-populations and LT.HSC 
# population: 

# Revised function to prioritize cell types
prioritize_cell_type <- function(cell_type) {
  priority_rank <- case_when(
    grepl("LTHSC$", cell_type) & !grepl("_broad", cell_type) ~ 1,
    grepl("^MPP[0-9]$", cell_type) ~ 2,
    grepl("MPP$", cell_type) ~ 3,
    grepl("STHSC$", cell_type) & !grepl("_broad", cell_type) ~ 4,
    TRUE ~ 5  # Default priority for unspecified types or broad types
  )
  return(priority_rank)
}

# Apply the revised prioritization logic
er_cell_types_long_prioritised_different <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)  # Remove the priority rank column after sorting

# Filter for the specific gene 'ENSMUSG00000054641'
gene_expression <- combined_data %>%
  filter(ensembl_gene_id == 'ENSMUSG00000054641') %>%
  select(-ensembl_gene_id) %>%
  t() %>%
  as.data.frame()

# Name the columns appropriately
colnames(gene_expression) <- 'ENSMUSG00000054641'
gene_expression$cell <- rownames(gene_expression)

# Merge with the main data frame
er_cell_types_long_prioritised_different <- er_cell_types_long_prioritised_different %>%
  left_join(gene_expression, by = "cell")

# Create the 'new_cell' column
er_cell_types_long_prioritised_different$new_cell <- paste(er_cell_types_long_prioritised_different$cell_type, sub(".*_(\\d+)$", "\\1", er_cell_types_long_prioritised_different$cell), sep = "_")

# Filter out cell types ending with '_broad' and other cell types apart from the LTHSCs and MPPs
filtered_er_cell_types_long_prioritised_different <- er_cell_types_long_prioritised_different %>%
  filter(!(cell_type %in% c('LMPP', 'CMP', 'GMP', 'MEP', 'ESLAM')) & !grepl('_broad$', cell_type))

# Calculate mean and SEM for each cell type, excluding '_broad'
average_expression_with_sem_filtered_new <- filtered_er_cell_types_long_prioritised_different %>%
  group_by(cell_type) %>%
  summarise(Average_Expression = mean(ENSMUSG00000054641, na.rm = TRUE),
            SEM = sd(ENSMUSG00000054641, na.rm = TRUE) / sqrt(n()))


```

```{r}
#| include: false

Mmrn1_subpop_MPP_plot <- ggplot(average_expression_with_sem_filtered_new, aes(x = cell_type, y = Average_Expression, fill = cell_type)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("green", "red", 'deeppink', "pink", 'violet')) +  
  geom_errorbar(aes(ymin = Average_Expression - SEM, ymax = Average_Expression + SEM), width = .2) +
  theme_minimal() +
  theme(
    plot.background = element_blank(), # Remove background
    panel.background = element_blank(), # Remove panel background
    panel.grid.major = element_blank(), # Remove major grid lines
    panel.grid.minor = element_blank(), # Remove minor grid lines
    axis.line = element_line(color = "black"), # Strong lines for X and Y axis
    axis.title.x = element_text(size = 0), # Bigger and bolder X axis title
    axis.title.y = element_text(size = 20), # Bigger and bolder Y axis title
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 16), # Bigger X axis labels
    axis.text.y = element_text(size = 22), # Bigger Y axis labels
    plot.title = element_text(hjust = 0, vjust = 1, size = 45, face = "bold"), # Bigger and bolder plot title
     plot.subtitle = element_text(size = 20, hjust = 0.5, vjust = 1), # Bigger plot subtitle
    legend.title = element_text(size = 20), # Corrected legend title size
    legend.text = element_text(size = 17) # Corrected legend text size
  ) +
  labs(x = "Cell Type", y = "Average Expression", title = "C)", subtitle = "Expression of Mmrn1 in LTHSC's and MPP's") +
  scale_y_continuous(limits = c(NA, 9)) + 
  annotate("segment", x = 3, xend = 4, y = 8.14285714, yend = 8.14285714, colour = "black", size = .5) + 
  annotate("segment", x = 1, xend = 3, y = 7.285714, yend = 7.285714, colour = "black", size = .5) +
  annotate("segment", x = 1, xend = 2, y = 7.5714, yend = 7.5714, colour = "black", size = .5) +  
  annotate("segment", x = 3, xend = 5, y = 7.85714286, yend = 7.85714286, colour = "black", size = .5) +  
  annotate("segment", x = 2, xend = 3, y = 7, yend = 7, colour = "black", size = .5) +   
  annotate("segment", x = 4, xend = 2, y = 8.42857143, yend = 8.42857143, colour = "black", size = .5) +
  annotate("segment", x = 5, xend = 2, y = 8.71428529, yend = 8.71428529, colour = "black", size = .5) +
  annotate("text", x = 3.5, y = 8.27, label = "NS", size = 2) +
  annotate("text", x = 1.5, y = 7.6, label = "*", size = 6) +
  annotate("text", x = 4, y = 7.85, label = "***", size = 6) +
  annotate("text", x = 2, y = 7.415, label = "NS", size = 2) +
  annotate("text", x = 2.5, y = 7.12, label = "NS", size = 2) +
  annotate("text", x = 1, y = 5.65, label = "5.149", size = 5) +
  annotate("text", x = 2, y = 4.2, label = "3.631", size = 5) +
  annotate("text", x = 3, y = 5.9, label = "4.971", size = 5) +
  annotate("text", x = 4, y = 2.6, label = "1.558", size = 5) +
  annotate("text", x = 5, y = 1.9, label = "1.329", size = 5) +
  annotate("text", x = 3, y = 8.55, label = "NS", size = 2) +
  annotate("text", x = 3.5, y = 8.71, label = "**", size = 6) 

# Save the plot
ggsave("figures/Mmrn1_subpop_MPP_plot.png", plot = Mmrn1_subpop_MPP_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# here we are creating a 3D PCA like previously but with the sub-population data: 

# Prioritize cell types and remove "_broad" from cell_type
er_cell_types_long <- er_cell_types_long %>%
  mutate(cell_type = gsub("_broad", "", cell_type),
         priority_rank = case_when(
           grepl("LTHSC", cell_type) ~ 1,
           grepl("MPP[0-9]", cell_type) ~ 2,
           grepl("^MPP$", cell_type) ~ 3,
           grepl("STHSC", cell_type) ~ 4,
           TRUE ~ 5
         )) %>%
  arrange(cell, priority_rank) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)

# Prepare a mapping from 'cell' to 'cell_type' while retaining numeric identifier
er_cell_types_long$numeric_id <- gsub("\\D", "", er_cell_types_long$cell)
er_cell_types_long$original_prefix <- gsub("_\\d+$", "", er_cell_types_long$cell)
er_cell_types_long$new_id <- paste(er_cell_types_long$cell_type, er_cell_types_long$numeric_id, sep = "_")

# Create a mapping dictionary
id_mapping <- setNames(er_cell_types_long$new_id, er_cell_types_long$cell)

# Check for duplicate entries in the 'cell' column
if(anyDuplicated(er_cell_types_long$cell)) {
  stop("Duplicate 'cell' entries found in 'er_cell_types_long'. Cannot create a unique mapping.")
}

# Filter combined_data to include only columns present in er_cell_types_long$cell
combined_data_PCA <- combined_data[, names(combined_data) %in% er_cell_types_long$cell]

# Use id_mapping to rename columns in combined_data
colnames(combined_data_PCA) <- sapply(colnames(combined_data_PCA), function(col_name) {
  if(col_name %in% names(id_mapping)) {
    return(id_mapping[col_name])
  } else {
    return(NA) # Prepare to mark for removal if no mapping found
  }
})


# Transpose combined_data for PCA analysis
combined_data_t <- t(combined_data_PCA)

normalized_data <- scale(combined_data_t)

pca_result <- prcomp(normalized_data, scale. = TRUE)

pca_data <- as.data.frame(pca_result$x)

# Create a mapping of new_id to cell_type
cell_type_mapping <- setNames(er_cell_types_long$cell_type, er_cell_types_long$new_id)

# Use the row names of pca_data to map each row to its cell type
pca_data$cell_type <- cell_type_mapping[rownames(pca_data)]



# This is a precautionary step to filter out "Undefined" and NA cell types
undefined_cells <- pca_data$cell_type %in% c("Undefined", NA)

# Additionally, check for any cell_type not present in er_cell_types_long
valid_cell_types <- unique(er_cell_types_long$cell_type)
undefined_cells <- undefined_cells | !pca_data$cell_type %in% valid_cell_types

# Here we are remvoing any undefined cells from pca_data
pca_data <- pca_data[!undefined_cells, ]



# Assign a neutral color for baseline expression to all cells
pca_data$Color <- 'grey'  # Neutral color representing baseline expression

cell_type_colors <- c('CMP' = 'yellow',
                  'GMP' = 'darkgreen',
                  'LMPP' = 'blue',
                  'LTHSC' = 'green',
                  'MEP' = 'orange',
                  'MPP' = 'red',
                  'MPP1' = 'deeppink',
                  'MPP2' = 'pink',
                  'MPP3' = 'purple')

# Prepare the initial 3D PCA plot with all cells in grey to represent baseline expression
PCA_sub_population <- plot_ly(data = pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
                                  marker = list(color = ~Color, size = 3, opacity = 0.5),  # Use the baseline color
                                  name = "Baseline Expression") %>%
  layout(scene = list(xaxis = list(title = "PC1"),
                      yaxis = list(title = "PC2"),
                      zaxis = list(title = "PC3")),
         legend = list(orientation = "h", # Horizontal legend
                       x = 0.5, # Center the legend on the x-axis
                       xanchor = 'center', # Anchor the legend in the center of its position
                       y = -0.2, # Position below the x-axis (negative for below the plot area)
                       yanchor = 'top', # Anchor the legend at the top of its position
                       font = list(size = 18)), # Larger font size for the legend
         showlegend = TRUE)

# Loop over each cell type and overlay their specific colors
for(cell_type in names(cell_type_colors)) {
  cells_of_type <- pca_data$cell_type == cell_type
  PCA_sub_population <- PCA_sub_population %>%
    add_trace(data = pca_data[cells_of_type, ], x = ~PC1, y = ~PC2, z = ~PC3,
              type = 'scatter3d', mode = 'markers',
              marker = list(color = cell_type_colors[cell_type], size = 3, opacity = 0.8),
              name = cell_type)
}

```

```{r}
#| include: false

# creating a URL using the plotly website

# Set Plotly credentials
Sys.setenv("plotly_username"="Jwomersley")
Sys.setenv("plotly_api_key"="qQihcRkBSTTX26hk0xlt")

# Ensure you've set your Plotly API credentials as environment variables
response <- plotly::api_create(PCA_sub_population, filename = "PCA_sub_population")
plot_url <- response$embed_url
print(plot_url)
```

```{r}
#| include: false

# Display the plot
PCA_sub_population <- PCA_sub_population %>%
  layout(autosize = F, # Adjust size as needed
         legend = FALSE)


PCA_sub_population <- PCA_sub_population %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 150, height = 210) %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
        title = list(  # Use a list to specify title properties
      text = "Sub-population",
      x = 1,  # Positions the title at the left; 0 is far left, 0.5 is center (default)
      xanchor = "right"  # Anchors the title text at the x position from its left side
    ),
         showlegend = FALSE)

#save as a HTML   
htmlwidgets::saveWidget(PCA_sub_population, "figures/HTML_files/PCA_sub_population", selfcontained = TRUE)
```

```{r}
#| include: false

# PCA showing CMPs in yellow and all other cells in grey to be displayed in the figure panel

# Define a group for CMP cells to highlight them
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('CMP'), "Highlighted", "Other")

# Define colors and opacities for the groups
color_scheme <- c("Highlighted" = "yellow", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_CMP <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_CMP <- plot_3d_pca_CMP %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_CMP <- plot_3d_pca_CMP %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
         title = "CMP",
         showlegend = FALSE)
```

```{r}
#| include: false

# PCA showing GMPs in green and all other cells in grey to be displayed in the figure panel

# Define a group for GMP cells to highlight them
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('GMP'), "Highlighted", "Other")

# Define colors and opacities for the groups
color_scheme <- c("Highlighted" = "darkgreen", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_GMP <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_GMP <- plot_3d_pca_GMP %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_GMP <- plot_3d_pca_GMP %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
         title = "GMP",
         showlegend = FALSE)
```

```{r}
#| include: false

# PCA showing LMPPs in blue and all other cells in grey to be displayed in the figure panel

# Define a group for LMPP cells to highlight them
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('LMPP'), "Highlighted", "Other")

# Define colors and opacities for the groups
color_scheme <- c("Highlighted" = "blue", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_LMPP <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_LMPP <- plot_3d_pca_LMPP %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_LMPP <- plot_3d_pca_LMPP %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
         title = "LMPP",
         showlegend = FALSE)
```

```{r}
#| include: false

# PCA showing MEPs in blue and all other cells in grey to be displayed in the figure panel

# Define a group for MEP cells to highlight them
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('MEP'), "Highlighted", "Other")

# Define colors and opacities for the groups
color_scheme <- c("Highlighted" = "orange", "Other" = "grey")
opacities <- c("Highlighted" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_MEP <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_MEP <- plot_3d_pca_MEP %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_MEP <- plot_3d_pca_MEP %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
         title = "MEP",
         showlegend = FALSE)
```

```{r}
#| include: false

# PCA showing MPP populations to be displayed in the figure panel

# Define a group for MPPs cells to highlight them
pca_data$cell_type_group <- ifelse(pca_data$cell_type %in% c('MPP', 'MPP1', 'MPP2', 'MPP3'), "Highlighted", "Other")

# Now, suppose we want to give each type of 'MPP' a different color but they are all 'Highlighted'
# We can redefine 'cell_type_group' to be more specific for coloring
pca_data$cell_type_group[pca_data$cell_type == 'MPP']  <- "MPP"
pca_data$cell_type_group[pca_data$cell_type == 'MPP1'] <- "MPP1"
pca_data$cell_type_group[pca_data$cell_type == 'MPP2'] <- "MPP2"
pca_data$cell_type_group[pca_data$cell_type == 'MPP3'] <- "MPP3"

# Define colors and opacities for each group
color_scheme <- c("MPP" = "red", "MPP1" = "deeppink", "MPP2" = "pink", "MPP3" = "purple", "Other" = "grey")
opacities <- c("MPP" = 0.8, "MPP1" = 0.8, "MPP2" = 0.8, "MPP3" = 0.8, "Other" = 0.3)

# Create the 3D PCA plot
plot_3d_pca_MPP <- plot_ly()

# Add markers for each group to control their appearance separately
for(group in unique(pca_data$cell_type_group)) {
  data_subset <- subset(pca_data, cell_type_group == group)
  
  plot_3d_pca_MPP <- plot_3d_pca_MPP %>%
    add_markers(data = data_subset, x = ~PC1, y = ~PC2, z = ~PC3,
                marker = list(size = 3, opacity = opacities[group], color = color_scheme[group]),
                name = group)
}

# Finalize the plot layout
plot_3d_pca_MPP <- plot_3d_pca_MPP %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
         title = "MPP",
         showlegend = FALSE)
```

```{r}
#| include: false

# selecting each of the top 12 differentially expressed genes to be highlighted and  used in 
# the figure panel.

# read in the raw data with row names as gene names: 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)

# combine the data
combined_data <- cbind(prog, hspc, lthsc)

# Transpose the data to have cells in rows and genes in columns 
combined_data <- t(combined_data)

# Perform PCA 
normalized_data <- scale(combined_data)

pca_result <- prcomp(normalized_data, scale. = TRUE)

# Create a data frame with PCA results 
pca_data <- as.data.frame(pca_result$x)

# Assign cell type information
cell_types <- c(rep("Prog", ncol(prog)))
cell_types <- c(cell_types, rep("HSPC", ncol(hspc)))
cell_types <- c(cell_types, rep("LTHSC", ncol(lthsc)))

# Add the cell_type variable to pca_data --------------------------------
pca_data$cell_type <- cell_types
  
# Define genes of interest with their names, Ensembl gene IDs, and colors
  genes_of_interest <- data.frame(
    GeneName = c("Mmrn1"),
    GeneID = c("ENSMUSG00000054641"),
    Color = c("red"), # Adjusted grey to lightgrey for better contrast
    stringsAsFactors = FALSE
  )
  
# Expression threshold
threshold <- 3

  
# Initialize all cells to be grey, then overlay with colors for high expressions
pca_data$Color <- 'grey' # Default color for all cells
  
# Prepare the initial 3D PCA plot with all cells in grey
  plot_3d_pca_mmrn1 <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
marker = list(size = 3, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
name = "Baseline Expression") %>%
layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "Mmrn1", showlegend = FALSE)
  
# Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$GeneID[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
  # Add trace for high expression of the current gene
    plot_3d_pca_mmrn1 <- plot_3d_pca_mmrn1 %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$GeneName[i],
                marker = list(size = 3, color = genes_of_interest$Color[i], opacity = 0.8))
  }
```

```{r}
#| include: false

# Add the cell_type variable to pca_data 
pca_data$cell_type <- cell_types
  
# Define genes of interest with their names, Ensembl gene IDs, and colors
  genes_of_interest <- data.frame(
    GeneName = c("ESAM"),
    GeneID = c("ENSMUSG00000001946"),
    Color = c("red"), # Adjusted grey to lightgrey for better contrast
    stringsAsFactors = FALSE
  )
  
# Expression threshold
threshold <- 3

  
# Initialize all cells to be grey, then overlay with colors for high expressions
  pca_data$Color <- 'grey' # Default color for all cells
  
# Prepare the initial 3D PCA plot with all cells in grey
  plot_3d_pca_ESAM <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers', 
marker = list(size = 3, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
name = "Baseline Expression") %>%
    layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "ESAM", showlegend = FALSE)
  
# Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$GeneID[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
# Add trace for high expression of the current gene
    plot_3d_pca_ESAM <- plot_3d_pca_ESAM %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$GeneName[i],
                marker = list(size = 3, color = genes_of_interest$Color[i], opacity = 0.8),
                showlegend = FALSE)
  }
```

```{r}
#| include: false

# Add the cell_type variable to pca_data 
pca_data$cell_type <- cell_types
  
# Define genes of interest with their names, Ensembl gene IDs, and colors
  genes_of_interest <- data.frame(
    GeneName = c("Cd34"),
    GeneID = c("ENSMUSG00000016494"),
    Color = c("red"), # Adjusted grey to lightgrey for better contrast
    stringsAsFactors = FALSE
  )
  
# Expression threshold
threshold <- 3

  
# Initialize all cells to be grey, then overlay with colors for high expressions
pca_data$Color <- 'grey' # Default color for all cells
  
# Prepare the initial 3D PCA plot with all cells in grey
plot_3d_pca_Cd34 <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
marker = list(size = 3, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
name = "Baseline Expression") %>%
    layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "Cd34", showlegend = FALSE)
  
  # Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$GeneID[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
    # Add trace for high expression of the current gene
    plot_3d_pca_Cd34 <- plot_3d_pca_Cd34 %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$GeneName[i],
                marker = list(size = 3, color = genes_of_interest$Color[i], opacity = 0.8),
                showlegend = FALSE)
  }
```

```{r}
#| include: false

# Add the cell_type variable to pca_data
pca_data$cell_type <- cell_types
  
# Define genes of interest with their names, Ensembl gene IDs, and colors
genes_of_interest <- data.frame(
    GeneName = c("Cd48"),
    GeneID = c("ENSMUSG00000015355"),
    Color = c("red"), # Adjusted grey to lightgrey for better contrast
    stringsAsFactors = FALSE
  )
  
# Expression threshold
threshold <- 3

  
# Initialize all cells to be grey, then overlay with colors for high expressions
pca_data$Color <- 'grey' # Default color for all cells
  
# Prepare the initial 3D PCA plot with all cells in grey
plot_3d_pca_Cd48 <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
marker = list(size = 3, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
name = "Baseline Expression") %>%
layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "Cd48", showlegend = FALSE)
  
# Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$GeneID[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
# Add trace for high expression of the current gene
    plot_3d_pca_Cd48 <- plot_3d_pca_Cd48 %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$GeneName[i],
                marker = list(size = 3, color = genes_of_interest$Color[i], opacity = 0.8),
                showlegend = FALSE)
  }
```

```{r}
#| include: false

# Add the cell_type variable to pca_data 
pca_data$cell_type <- cell_types
  
# Define genes of interest with their names, Ensembl gene IDs, and colors
  genes_of_interest <- data.frame(
    GeneName = c("Procr"),
    GeneID = c("ENSMUSG00000027611"),
    Color = c("red"), # Adjusted grey to lightgrey for better contrast
    stringsAsFactors = FALSE
  )
  
# Expression threshold
threshold <- 3

  
# Initialize all cells to be grey, then overlay with colors for high expressions
pca_data$Color <- 'grey' # Default color for all cells
  
# Prepare the initial 3D PCA plot with all cells in grey
plot_3d_pca_Procr <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
marker = list(size = 3, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
name = "Baseline Expression") %>%
    layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ), title = "Procr", showlegend = FALSE)
  
# Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$GeneID[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
# Add trace for high expression of the current gene
plot_3d_pca_Procr <- plot_3d_pca_Procr %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$GeneName[i],
                marker = list(size = 3, color = genes_of_interest$Color[i], opacity = 0.8),
                showlegend = FALSE)
  }
```

```{r}
# Heatmap using heirarchical clustering.

# Load individual datasets again with the ensembl_gene_ids being the the row names 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)


# Combine the datasets into one matrix
# Assuming cells are in columns and genes in rows
combined_data <- cbind(prog, hspc, lthsc)

# Function to prioritize cell types
prioritize_cell_type <- function(cell_type) {
  # Assign priority rank, explicitly ignore _broad cells by assigning NULL
  if(grepl("_broad", cell_type)) {
    return(NA)  # Assign NA to _broad cells to filter them out later
  } else {
    return(case_when(
      grepl("LTHSC$", cell_type) ~ 1,
      grepl("^MPP$", cell_type) ~ 2,
      grepl("MPP[0-9]$", cell_type) ~ 3,
      grepl("STHSC$", cell_type) ~ 4,
      TRUE ~ 5  # Default priority for unspecified types
    ))
  }
}

# Create a dataframe to track the occurrence of each new_id
make_unique_new_id <- function(df) {
  occurrence_df <- df %>%
    group_by(new_id) %>%
    mutate(occurrence = row_number()) %>%
    ungroup()
  
  # For each new_id, if it's the first occurrence, keep it as is. 
  # If it's a subsequent occurrence, append a suffix starting from .1
  # this is to match the data in the combined_data matrix and is to prevent error in matching 
  # ids
  occurrence_df$new_id <- ifelse(occurrence_df$occurrence == 1, 
                                 occurrence_df$new_id, 
                                 paste0(occurrence_df$new_id, ".", occurrence_df$occurrence - 1))
  
  # Drop the temporary 'occurrence' column
  occurrence_df <- select(occurrence_df, -occurrence)
  
  return(occurrence_df)
}


# Apply prioritization logic and filter out _broad cells
er_cell_types_long_prioritised <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  filter(!is.na(priority_rank)) %>%  # Filter out _broad cells
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)  # Remove the priority rank column after sorting

# Apply the function to your dataframe
er_cell_types_long_prioritised <- make_unique_new_id(er_cell_types_long_prioritised)

# Update column names in combined_data based on the mapping
mapping <- setNames(er_cell_types_long$new_id, er_cell_types_long$cell)

# Update column names in combined_data
new_colnames <- sapply(colnames(combined_data), function(col_name) {
  if(col_name %in% names(mapping)) {
    return(mapping[col_name])
  } else {
    return(col_name)
  }
})

colnames(combined_data) <- new_colnames


# Ensure 'cell' column in er_cell_types_long is unique for accurate mapping
if(!anyDuplicated(er_cell_types_long$cell)) {
  # Create a mapping of original cell names to new cell_type identifiers
  cell_to_new_id_map <- setNames(er_cell_types_long$cell_type, er_cell_types_long$cell)
  
  # Generate new column names for combined_data by looking up each original column name in the map
  new_colnames <- sapply(colnames(combined_data), function(col_name) {
    # Extract the cell name prefix (e.g., "Prog_001") from the combined column name
    cell_name_prefix <- sub("^(Prog|HSPC|LTHSC)_", "\\1_", col_name)
    # Lookup the new cell_type identifier using the cell name prefix
    if(cell_name_prefix %in% names(cell_to_new_id_map)) {
      # Return the new identifier with original numeric suffix retained
      return(paste(cell_to_new_id_map[cell_name_prefix], sub(".*_(\\d+)$", "\\1", col_name), sep = "_"))
    } else {
      # If no mapping found, return the original column name
      return(col_name)
    }
  })
  
  # Update column names in combined_data
  colnames(combined_data) <- new_colnames
} else {
  stop("Duplicate 'cell' entries found in 'er_cell_types_long'. Cannot create a unique mapping.")
}


# Remove columns with names starting with "Prog_"
combined_data <- combined_data[, !grepl("^Prog_", colnames(combined_data))]

# Filter combined data for the specified ensembl_gene_id
# Extract the ensembl_gene_id column and create the vector
gene_names <- head(top_differentially_expressed_genes_no_duplicates$external_gene_name, 50)

# Retrieve Ensembl gene IDs based on the external gene names
genes_ensembl_ids <- getBM(attributes = c("external_gene_name", "ensembl_gene_id"),
                    filters = "external_gene_name",
                    values = gene_names,
                    mart = ensembl)
# create a vector for the ensembl_gene_ids
top_genes <- genes_ensembl_ids$ensembl_gene_id 

#filter the data for just the top genes 
combined_data_filtered <- combined_data[top_genes, ]

# Perform hierarchical clustering with complete linkage method for rows
hc_rows <- hclust(dist(combined_data_filtered, method = "euclidean"), method = "ward.D2")

# Perform hierarchical clustering with complete linkage method for columns
hc_cols <- hclust(dist(t(combined_data_filtered), method = "euclidean"), method = "ward.D2")

# Specify the number of clusters you want to cut the dendrogram into
num_clusters <- 4

# Cut the dendrogram to obtain cluster labels for rows and columns
clusters_rows <- cutree(hc_rows, k = num_clusters)
cluster_cols <- cutree(hc_cols, k = num_clusters)

# Get the order of rows and columns based on clustering
order_rows <- order.dendrogram(as.dendrogram(hc_rows))
order_cols <- order.dendrogram(as.dendrogram(hc_cols))

# Reorder the combined_data based on the clustering
combined_data_reordered <- combined_data_filtered[order_rows, order_cols]

# IMPORTANT: Reorder 'cluster_cols' to match the new order of columns in 'combined_data_reordered'
reordered_cluster_cols <- cluster_cols[order_cols]

# Now create annotation_data using the reordered cluster assignments
annotation_data <- data.frame(
  Cell = colnames(combined_data_reordered),  # Use reordered column names
  Cluster = reordered_cluster_cols           # Use reordered cluster assignments
)

# Create CellType column by removing anything after "_" in the cell names
annotation_data$Sub_Population <- sub("_.*", "", annotation_data$Cell)

# Define custom colors for the clusters
cluster_colours <- c("purple", "cyan", "orange", "deeppink")  # Example custom colors

Sub_Population_colours <- c('CMP' = 'yellow',
                  'GMP' = 'darkgreen',
                  'LMPP' = 'blue',
                  'LTHSC' = 'green',
                  'MEP' = 'orange',
                  'MPP' = 'red')

CellType_colours <- c('LT.HSC' = 'green',
                  'HSPC' = 'red',
                  'Prog' = 'blue')

# some cells didnt map correctly or didt have a sub-population definition so we are jusr removing them here 

# Remove rows with "HSPC" in the Sub_Population column
annotation_data <- subset(annotation_data, Sub_Population != "HSPC")

# even though the code above specificed for cells to be named generic MPP over MPP[1-3],
# ther.  is still potentially some MPP[1-3] in the data set. 
# This is an issue as there are too few cells with the MPP[0-3] definition to be able to be    # seen so we want all MPPs to be defined under one umbrella: 

# Replace "MPP1" with "MPP" in the Sub_Population column of annotation_data
annotation_data$Sub_Population <- gsub("MPP1", "MPP", annotation_data$Sub_Population)


# Replace "MPP1" with "MPP" in the Sub_Population column of annotation_data
annotation_data$Sub_Population <- gsub("MPP2", "MPP", annotation_data$Sub_Population)


# Replace "MPP1" with "MPP" in the Sub_Population column of annotation_data
annotation_data$Sub_Population <- gsub("MPP3", "MPP", annotation_data$Sub_Population)

# Sort annotation_data by Cluster and then by CellType within each Cluster
annotation_data_sorted <- annotation_data %>%
  arrange(Cluster, Sub_Population, Cell)

# Use the sorted annotation_data to define the new column order for combined_data_reordered
new_col_order <- match(annotation_data_sorted$Cell, colnames(combined_data_reordered))

# Apply this new column order to combined_data_reordered
combined_data_final <- combined_data_reordered[, new_col_order]

# remvoing the Cell column
annotation_data_sorted <- subset(annotation_data_sorted, select = -c(Cell))


# Loop over each row name in combined_data_final
for (i in seq_along(rownames(combined_data_final))) {
    # Find the matching gene name for the current Ensembl ID
    matched_gene_name <- genes_ensembl_ids$external_gene_name[match(rownames(combined_data_final)[i], genes_ensembl_ids$ensembl_gene_id)]
    
    # Update the row name if a match is found
    if (!is.na(matched_gene_name)) {
        rownames(combined_data_final)[i] <- matched_gene_name
    }
    # If no match is found, do nothing, leaving the Ensembl ID as the row name
}

# Ensure annotation_data_sorted has a column for row names
annotation_data_sorted <- annotation_data_sorted %>%
  rownames_to_column("row_names")

# Join the data frames based on the new_id column and row_names
annotation_data_sorted <- annotation_data_sorted %>%
  left_join(er_cell_types_long_prioritised, by = c("row_names" = "new_id")) %>%
  # Create the 'CellType' column from 'original_prefix'
  mutate(CellType = original_prefix) %>%
  # Now, choose to keep all original columns from annotation_data_sorted plus the new CellType column
  select(-original_prefix, everything(), CellType)


# Set the first column as row names
row.names(annotation_data_sorted) <- annotation_data_sorted[[1]]


annotation_data_sorted <- subset(annotation_data_sorted, select = -c(cell, cell_type, numeric_id, original_prefix, row_names))
```

```{r}
#| include: false

# Note the clustering is set to FALSE in the code below because we have previously ordered the # rows and columns in our data set to be in the clusters. 
heatmap_subpopulation_clustering <- pheatmap(
  combined_data_final, cellheight = 5.7,
  cluster_rows = FALSE,   # Cluster rows
  cluster_cols = FALSE,  # Do not cluster columns
  show_rownames = TRUE,  # Show row names
  show_colnames = FALSE,  # Do not show column names
  fontsize_row = 6,
  fontsize_col = 6,
  angle_col = 45,
  color = colorRampPalette(c("blue", "white", "red"))(100),
  legend = TRUE,
  annotation_col = annotation_data_sorted,
  treeheight_row = 5,     # Hide dendrogram lines for rows
  treeheight_col = 5,     # Hide dendrogram lines for columns
  annotation_colors = list(Sub_Population = Sub_Population_colours, Cluster = cluster_colours,CellType = CellType_colours)  # Specify custom colors for the cluster annotations
)

# Save the plot
ggsave("figures/heatmap_subpopulation_clustering.png", plot = heatmap_subpopulation_clustering, width = 10, height = 6, dpi = 300)
```

```{r}
#| include: false
#Mmrn1, Procr and CD150 average expression plot: 

# Load individual datasets again with the ensembl_gene_ids being the the row names 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)


# Combine the datasets into one matrix
# Assuming cells are in columns and genes in rows
combined_data <- cbind(prog, hspc, lthsc)

# reinitalise the er_cell_types_long
er_cell_types_long <- pivot_longer(er_cell_types, cols = -cell, names_to = "cell_type", values_to = "value") %>%
  filter(value == 1) %>%
  select(-value)

# new prioritisation logic with ESLAM cells set as highest priority 
prioritize_cell_type <- function(cell_type) {
  priority_rank <- case_when(
    grepl("ESLAM", cell_type) ~ 1,  # Highest priority for ESLAM cells
    grepl("LTHSC", cell_type) & !grepl("_broad", cell_type) ~ 2,
    grepl("^MPP$", cell_type) ~ 3,
    grepl("MPP[0-9]", cell_type) ~ 4,
    grepl("STHSC", cell_type) & !grepl("_broad", cell_type) ~ 5,
    TRUE ~ 6  # Default priority for unspecified types or broad types
  )
  return(priority_rank)
}


# Apply prioritization logic
er_cell_types_long_ESLAM <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)

er_cell_types_long_ESLAM <- er_cell_types_long_ESLAM %>%
  mutate(new_id = paste(cell_type, sub(".*_(\\d+)$", "\\1", cell), sep = "_"))


# Update column names in combined_data based on the mapping
mapping <- setNames(er_cell_types_long_ESLAM$new_id, er_cell_types_long_ESLAM$cell)

# Update column names in combined_data
new_colnames <- sapply(colnames(combined_data), function(col_name) {
  if(col_name %in% names(mapping)) {
    return(mapping[col_name])
  } else {
    return(col_name)
  }
})

colnames(combined_data) <- new_colnames

#Here we are looking at Mmrn1, Procr and CD150 average expression: 

# Filter for the specific genes using the Ensembl gene IDs
gene_ids_of_interest <- c('ENSMUSG00000054641', 'ENSMUSG00000027611', 'ENSMUSG00000015316')

# Filter rows based on these gene IDs
gene_expression <- combined_data[rownames(combined_data) %in% gene_ids_of_interest, ]

# Transpose the filtered data
gene_expression <- t(gene_expression)

gene_expression <- as.data.frame(gene_expression)

gene_expression$cell <- rownames(gene_expression)

gene_expression$new_cell <- sub("_\\d+$", "", gene_expression$cell)

# Rename columns using dplyr::rename to avoid any naming conflict
gene_expression <- gene_expression %>%
  dplyr::rename(Mmrn1 = ENSMUSG00000054641, EPCR = ENSMUSG00000027611, CD150 = ENSMUSG00000015316)


# Assuming 'df' has columns 'cell_type', 'Mmrn1', and 'EPCR'
# First, ensure 'cell_type' is correctly filtered and not including '_broad', there should not be any in there this is just ensuring there isnt. 
gene_expression <- gene_expression %>%
  filter(new_cell %in% c("LTHSC", "ESLAM", "MEP", "CMP", "GMP", "LMPP", "MPP"),
         !grepl("_broad", new_cell))

# For accurate SEM calculation, ensure there's a grouping step before summarise
# Here, we pivot longer first to make 'Gene' a column, then calculate mean and SEM
gene_expression_SEM <- gene_expression %>%
  pivot_longer(cols = c("Mmrn1", "EPCR", "CD150"), names_to = "Gene", values_to = "Expression") %>%
  group_by(new_cell, Gene) %>%
  summarise(
    Average_Expression = mean(Expression, na.rm = TRUE),
    SEM = sd(Expression, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )


gene_expression_SEM$Gene <- factor(gene_expression_SEM$Gene, levels = c("Mmrn1", "EPCR", "CD150"))

# Define colors for each gene
gene_colors <- c(Mmrn1 = "#E41A1C", EPCR = "#377EB8", CD150 = "#984EA3")


```

```{r}
#| include: false
# Assuming filtered_df is your dataframe and it has columns for cell types and gene expressions
# Define the cell types shown in your graph
selected_cell_types <- c("CMP", "ESLAM", "GMP", "LMPP", "LTHSC", "MEP", "MPP")

# Define the genes to compare
genes <- c("Mmrn1", "EPCR", "CD150")

# Initialize an empty list to store the results
t_test_results <- list()

# Loop through each selected cell type
for (subtype in selected_cell_types) {
  # Subset the data for the current cell type
  subset_data <- gene_expression %>% filter(new_cell == subtype)
  
  # Perform pairwise t-tests for each gene combination
  for (i in 1:(length(genes)-1)) {
    for (j in (i+1):length(genes)) {
      # Perform t-test for the gene pair
      t_test_result <- t.test(subset_data[[genes[i]]], subset_data[[genes[j]]])
      
      # Create a label for this test
      test_label <- paste(subtype, genes[i], "vs", genes[j], sep = " - ")
      
      # Store the formatted p-value in the list
      t_test_results[[test_label]] <- formatC(t_test_result$p.value, format = "f", digits = 10)
    }
  }
}

# Print the formatted p-values for each comparison
cat("Pairwise T-Test P-values:\n")
for (test_label in names(t_test_results)) {
  cat(test_label, "P-value:", t_test_results[[test_label]], "\n")
}



# T.test for LT.HSC and MPP -----------------------------------------------

# Assuming 'df' contains the dataset with columns 'cell_type', 'Mmrn1', 'EPCR', and 'CD150'

# Filter the data for MPPs and LT.HSCs
mpps_data <- gene_expression %>% filter(new_cell == "MPP")
lt_hscs_data <- gene_expression %>% filter(new_cell == "LTHSC")

# Perform t-test for CD150 expression in MPPs vs LT.HSCs
t_test_result <- t.test(mpps_data$CD150, lt_hscs_data$CD150)

# Print the result
cat("T-Test Result for CD150 expression in MPPs vs LT.HSCs:\n")
cat("P-value:", formatC(t_test_result$p.value, format = "f", digits = 20), "\n")
```

```{r}
#| include: false

# Define the desired order for cell types
cell_type_order <- c("CMP", "ESLAM", "GMP", "LMPP", "LTHSC", "MEP", "MPP")

# Convert 'new_cell' to a factor with levels defined by 'cell_type_order'
gene_expression$new_cell <- factor(gene_expression$new_cell, levels = cell_type_order)

# Now, plotting with error bars
ESLAM_mmrn1_plot <- ggplot(gene_expression_SEM, aes(x = new_cell, y = Average_Expression, fill = Gene)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.5), width = 0.5) +
  geom_errorbar(aes(ymin = Average_Expression - SEM, ymax = Average_Expression + SEM), 
                width = 0.2, position = position_dodge(width = 0.5)) +
  scale_fill_manual(values = gene_colors, name = "Gene") +
  labs(title = "E)", subtitle = "Procr, CD150 and Mmrn1 Average Expression",
       x = "", y = "Average Expression") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, vjust = 1, size = 30, face = "bold"), # Bigger and bolder title
     plot.subtitle = element_text(size = 20, hjust = 0.5, vjust = 1), # Bigger plot subtitle
        axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        legend.position = "side") + 
  annotate("segment", x = 0.75, xend = 1, y = 1.3, yend = 1.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 0.75, xend = 0.75, y = 1.3, yend = 1.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1, xend = 1, y = 1.3, yend = 1.2, colour = "black", linewidth = 0.8) +
  annotate("text", x = 0.875, y = 1.43, label = "NS", size = 3) +
  annotate("segment", x = 1, xend = 1.25, y = 1.6, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1, xend = 1, y = 1.6, yend = 1.5, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.25, xend = 1.25, y = 1.6, yend = 1.5, colour = "black", linewidth = 0.8) +
  annotate("text", x = 1.125, y = 1.73, label = "NS", size = 3) +
  annotate("segment", x = 0.75, xend = 1.25, y = 1.9, yend = 1.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 0.75, xend = 0.75, y = 1.9, yend = 1.8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.25, xend = 1.25, y = 1.9, yend = 1.8, colour = "black", linewidth = 0.8) +
  annotate("text", x = 1, y = 2.03, label = "NS", size = 3) +
  annotate("segment", x = 1.75, xend = 2, y = 7.8, yend = 7.8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.75, xend = 1.75, y = 7.8, yend = 7.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2, xend = 2, y = 7.8, yend = 7.7, colour = "black", linewidth = 0.8) +
  annotate("text", x = 1.875, y = 7.93, label = "NS", size = 3) +
  annotate("segment", x = 2, xend = 2.25, y = 8.1, yend = 8.1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2, xend = 2, y = 8.1, yend = 8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.25, xend = 2.25, y = 8.1, yend = 8, colour = "black", linewidth = 0.8) +
  annotate("text", x = 2.125, y = 8.1, label = "****", size = 6) +
  annotate("segment", x = 1.75, xend = 2.25, y = 8.4, yend = 8.4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.75, xend = 1.75, y = 8.4, yend = 8.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.25, xend = 2.25, y = 8.4, yend = 8.3, colour = "black", linewidth = 0.8) +
  annotate("text", x = 2, y = 8.4, label = "****", size = 6) +
  annotate("segment", x = 2.75, xend = 3, y = 1.1, yend = 1.1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.75, xend = 2.75, y = 1.1, yend = 1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3, xend = 3, y = 1.1, yend = 1, colour = "black", linewidth = 0.8) +
  annotate("text", x = 2.875, y = 1.23, label = "NS", size = 3) +
  annotate("segment", x = 3, xend = 3.25, y = 1.4, yend = 1.4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3, xend = 3, y = 1.4, yend = 1.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.25, xend = 3.25, y = 1.4, yend = 1.3, colour = "black", linewidth = 0.8) +
  annotate("text", x = 3.125, y = 1.53, label = "NS", size = 3) +
  annotate("segment", x = 2.75, xend = 3.25, y = 1.7, yend = 1.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.75, xend = 2.75, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.25, xend = 3.25, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("text", x = 3, y = 1.83, label = "NS", size = 3) +
  annotate("segment", x = 3.75, xend = 4, y = 2.6, yend = 2.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.75, xend = 3.75, y = 2.6, yend = 2.5, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4, xend = 4, y = 2.6, yend = 2.5, colour = "black", linewidth = 0.8) +
  annotate("text", x = 3.875, y = 2.6, label = "*", size = 6) +
  annotate("segment", x = 4, xend = 4.25, y = 2.9, yend = 2.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4, xend = 4, y = 2.9, yend = 2.8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.25, xend = 4.25, y = 2.9, yend = 2.8, colour = "black", linewidth = 0.8) +
  annotate("text", x = 4.125, y = 2.9, label = "****", size = 6) +
  annotate("segment", x = 3.75, xend = 4.25, y = 3.2, yend = 3.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.75, xend = 3.75, y = 3.2, yend = 3.1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.25, xend = 4.25, y = 3.2, yend = 3.1, colour = "black", linewidth = 0.8) +
  annotate("text", x = 4, y = 3.2, label = "****", size = 6) +
  annotate("segment", x = 4.75, xend = 5, y = 6, yend = 6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.75, xend = 4.75, y = 6, yend = 5.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5, xend = 5, y = 6, yend = 5.9, colour = "black", linewidth = 0.8) +
  annotate("text", x = 4.875, y = 6.13, label = "NS", size = 3) +
  annotate("segment", x = 5, xend = 5.25, y = 6.3, yend = 6.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5, xend = 5, y = 6.3, yend = 6.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.25, xend = 5.25, y = 6.3, yend = 6.2, colour = "black", linewidth = 0.8) +
  annotate("text", x = 5.125, y = 6.3, label = "****", size = 6) +
  annotate("segment", x = 4.75, xend = 5.25, y = 6.6, yend = 6.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.75, xend = 4.75, y = 6.6, yend = 6.5, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.25, xend = 5.25, y = 6.6, yend = 6.5, colour = "black", linewidth = 0.8) +
  annotate("text", x = 5, y = 6.6, label = "****", size = 6) +
  annotate("segment", x = 6, xend = 6.25, y = 2, yend = 2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6, xend = 6, y = 2, yend = 1.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.25, xend = 6.25, y = 2, yend = 1.9, colour = "black", linewidth = 0.8) +
  annotate("text", x = 5.875, y = 1.83, label = "NS", size = 3) +
  annotate("segment", x = 5.75, xend = 6, y = 1.7, yend = 1.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6, xend = 6, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.75, xend = 5.75, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("text", x = 6.125, y = 2, label = "****", size = 6) +
  annotate("segment", x = 5.75, xend = 6.25, y = 2.4, yend = 2.4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.75, xend = 5.75, y = 2.4, yend = 2.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.25, xend = 6.25, y = 2.4, yend = 2.3, colour = "black", linewidth = 0.8) +
  annotate("text", x = 6, y = 2.4, label = "***", size = 6) +
  annotate("segment", x = 6.75, xend = 7, y = 3.7, yend = 3.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.75, xend = 6.75, y = 3.7, yend = 3.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7, xend = 7, y = 3.7, yend = 3.6, colour = "black", linewidth = 0.8) +
  annotate("text", x = 6.875, y = 3.83, label = "NS", size = 3) +
  annotate("segment", x = 7, xend = 7.25, y = 4, yend = 4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7, xend = 7, y = 4, yend = 3.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7.25, xend = 7.25, y = 4, yend = 3.9, colour = "black", linewidth = 0.8) +
  annotate("text", x = 7.125, y = 4, label = "****", size = 6) +
  annotate("segment", x = 6.75, xend = 7.25, y = 4.3, yend = 4.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.75, xend = 6.75, y = 4.3, yend = 4.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7.25, xend = 7.25, y = 4.3, yend = 4.2, colour = "black", linewidth = 0.8) +
  annotate("text", x = 7, y = 4.3, label = "****", size = 6) 

# Save the plot
ggsave("figures/ESLAM_mmrn1_plot.png", plot = ESLAM_mmrn1_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# first i am loading in my raw data files 
# Load our qPCR data from Excel
qPCR_raw <- read_excel("qPCR_data/qPCR_raw_data.xlsx")

#i am writing as a html to be uploaded to github so a URL can be made so the reader of the html output can see the raw data files 

# Create interactive DT tables for each dataset
dt_qPCR_raw <- datatable(qPCR_raw, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_qPCR_raw, "qPCR_data/HTML/qPCR_raw_data.html", selfcontained = TRUE)

# it comes up with a warning for the tables indicating they are too large but when inspecting them, the tables seem to be complete. For larger data sets one will likely not be able to use datatables. 

```

```{r}
#| include: false

# To perfrom statistical analysis we first filtered the data for PROG, LT.HSC, and MPP cell types
prog_data <- subset(qPCR_raw, cell_type %in% c("PROG4", "PROG2", "PROG7", "PROG3"))
lthsc_data <- subset(qPCR_raw, cell_type %in% c("LT.HSC11", "LT.HSC5", "LT.HSC6", "LT.HSC7", "LT.HSC12"))
mpp_data <- subset(qPCR_raw, cell_type %in% c("MPP6", "MPP7", "MPP11", "MPP12"))

# Perform t-tests between PROG and LT.HSC
t_test_prog_lthsc <- t.test(prog_data$Mmrn1_mean, lthsc_data$Mmrn1_mean)
print("T-test between PROG and LT.HSC:")
print(t_test_prog_lthsc)

# Perform t-tests between PROG and MPP
t_test_prog_mpp <- t.test(prog_data$Mmrn1_mean, mpp_data$Mmrn1_mean)
print("T-test between PROG and MPP:")
print(t_test_prog_mpp)

# Perform t-tests between LT.HSC and MPP
t_test_lthsc_mpp <- t.test(lthsc_data$Mmrn1_mean, mpp_data$Mmrn1_mean)
print("T-test between LT.HSC and MPP:")
print(t_test_lthsc_mpp)

# This is a function to group cell types
group_cell_types <- function(cell_type) {
  if(grepl("MPP", cell_type)) {
    return("MPP")
  } else if(grepl("PROG", cell_type)) {
    return("PROG")
  } else if(grepl("LT.HSC", cell_type)) {
    return("LT.HSC")
  } else {
    return(cell_type)
  }
}

# Apply grouping function to cell_type to get a new column, basically we are removing the numbers which specify which specifc cell, eg: MPP4 is now just MPP 
qPCR_raw$cell_type_grouped <- sapply(qPCR_raw$cell_type, group_cell_types)

# Calculate mean expression and standard error for each grouped cell type
qPCR_data_processed <- qPCR_raw %>%
  group_by(cell_type_grouped) %>%
  summarise(
    Mmrn1_expression = mean(Mmrn1_mean),
    SE = if(n() > 1) sd(Mmrn1_mean) / sqrt(n()) else NA_real_ # Only calculate SE for groups with more than 1 data point
  )

```

```{r}
#| include: false

# Defining the colours for each cell type 
custom_colors <- c("PROG" = "blue", "MPP" = "red", "LT.HSC" = "green")

# Create a bar plot with error bars
qPCR_plot <- ggplot(qPCR_data_processed, aes(x = cell_type_grouped, y = Mmrn1_expression, fill = cell_type_grouped)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Mmrn1_expression - SE, 
                    ymax = Mmrn1_expression + SE),
                position = position_dodge(width = 0.5), width = 0.2) +
  labs(x = NULL, y = "Relative Abundance", fill = "CellType", title = "F)", subtitle = "Procr, CD150 and Mmrn1 Average Expression") + # Remove X axis title 
  theme_minimal() +
  theme(
    axis.text = element_text(size = 15), # Increase axis text size
    axis.title = element_text(size = 20), # Increase axis title size
    panel.grid.major = element_blank(), # Remove major grid lines
    panel.grid.minor = element_blank(), # Remove minor grid line 
    plot.title = element_text(hjust = 0, vjust = 1, size = 30, face = "bold"), # Bigger and bolder title
    plot.subtitle = element_text(size = 20, hjust = 0.5, vjust = 1), # Bigger plot subtitle, 
    legend.text = element_text(size = 15), legend.title = element_text(size = 12), # Increase legend text size
    axis.line = element_line(color = "black"),
    legend.key.size = unit(1, "cm"), # Center and increase title size
    plot.margin = margin(t = 0, r = 0, b = 30, l = 0, unit = "pt")
  ) + scale_fill_manual(values = custom_colors) +  ylim(0, 13) +
  annotate("text", x = 1, y = 6.82, label = "4.861", size = 5) +
  annotate("text", x = 2, y = 9.62, label = "5.266", size = 5) +
  annotate("text", x = 3, y = 2.22, label = "1.411", size = 5) +
  annotate("segment", x = 1, xend = 2, y = 10.4, yend = 10.4, colour = "black", size = 1) +
  annotate("segment", x = 1, xend = 1, y = 10.4, yend = 10.1, colour = "black", size = 1) +
  annotate("segment", x = 2, xend = 2, y = 10.4, yend = 10.1, colour = "black", size = 1) +
  annotate("segment", x = 2, xend = 2, y = 11.5, yend = 11.2, colour = "black", size = 1) +
  annotate("segment", x = 3, xend = 3, y = 11.5, yend = 11.2, colour = "black", size = 1) +
  annotate("segment", x = 2, xend = 3, y = 11.5, yend = 11.5, colour = "black", size = 1) +
  annotate("segment", x = 1, xend = 1, y = 12.6, yend = 12.3, colour = "black", size = 1) +
  annotate("segment", x = 3, xend = 3, y = 12.6, yend = 12.3, colour = "black", size = 1) +
  annotate("segment", x = 1, xend = 3, y = 12.6, yend = 12.6, colour = "black", size = 1) +
  annotate("text", x = 1.5, y = 10.75, label = "P = 0.929", size = 5) +
  annotate("text", x = 2.5, y = 11.85, label = "P = 0.4048", size = 5) +
  annotate("text", x = 2, y = 12.95, label = "P = 0.08899", size = 5) 

# Save the plot
ggsave("figures/qPCR_plot.png", plot = qPCR_plot, width = 10, height = 6, dpi = 300)

```

# Introduction:

Hematopoietic stem cells (HSCs) are at the apex of the differentiation hierarchy and are defined by their ability to differentiate and produce the entire haematopoietic system upon transplantation. In fact, for over 60 years HSC transplantation has been the main treatment for haematological malignancies, whereby success is strongly correlated to the number of HSCs transplanted [@eaves2015]. Long-term hematopoietic stem cells (LT-HSCs) sit within this HSC pool and maintain blood production and respond to inflammation, blood loss, and injury [@gur-cohen2016]. LT-HSCs are found in the bone marrow (BM) microenvironment, the main site of adult haematopoiesis, in a non-proliferative, quiescent mode via adhesive interactions [@morrison2014; @boulais2015; @mendelson2014]. They are of much interest due to their capacity to support long-term hematopoietic reconstitution meaning they are capable of repopulating the bone marrow in functional transplantation assays, which requires high self-renewal ability, developmental potential and homing [@gur-cohen2016; @notta2011]. A long-standing goal in the field has been the identification and characterization of these functional LT-HSCs. Thus far, strategies for the purification of HSCs utilise primarily fluorescence activated cell sorter (FACS)--based protocols that rely on the detection of cell-surface antigens that are differentially expressed on HSCs [@berman1985; @spangrude1989]. Whilst numerous landmark studies have uncovered the origins of HSCs and the key factors that influence their functionality [@bertrand2010; @hamey2017; @baron2018; @hou2020], the selection of HSCs for research primarily depends on various cell surface markers, which functions remain poorly understood. Indeed, single-cell and serial transplantation studies have revealed significant heterogeneity in both the mature cell production and self-renewal durability of individual HSCs isolated using these markers [@beerman2010; @dykstra2007; @goodell1996; @morita2010]. Its believed this functional heterogeneity is being controlled via intrinsic and extrinsic mechanisms [@copley2013; @wilkinson2013], but the specific molecular mechanisms that dictate HSC expansion and maintenance are largely unknown. For almost 3 decades, researchers have developed protocols for the prospective isolation of increasingly refined hematopoietic stem and progenitor cell (HSPC) populations toward this LT-HSC phenotype. Currently, there are four widely used HSC isolation protocols, whereby ESLAM cells (CD150+ EPCR+CD48−CD45+) have been found to have the one of the highest long term repopulation potentials [@wilson2015; @adolfsson2001; @weksberg2008; @kent2009; @kent2016]. ESLAM cells utilise endothelial protein C receptor (EPCR), also known as CD201 and encoded by the gene Procr, as one of few known markers that overtly identifies hematopoietic stem cells within murine bone marrow [@balazs2006; @iwasaki2010; @zhou2016; @fares2017; @subramaniam2019; @papa2020; @anjos-afonso2022; @rix2022; @lin2023]. When used alongside alongside CD34+ hematopoietic stem and progenitor cells (HSPCs), which are considered to sustain human haematopoiesis, EPCR significantly enhances the isolation of cells which have a high repopulating and self-renewal abilities in humans [@anjos-afonso2022; @balazs2006; @fares2017; @iwasaki2010; @papa2020; @rix2022; @subramaniam2019; @zhou2016]. Moreover, CD150 is used as another marker used by ESLAM cells, to identify HSCs with high self-renewal and reconstituting potential [@thomas1989; @shivtiel2008; @kiel2005; @papathanasiou2009; @beerman2010; @morita2010]. The combination of EPCR and CD150 therefore provides an effective strategy for isolating functionally HSCs allowing for purities of more than 50%. However, no current method yields a single homogeneous HSC population. Additionally, the restrictive gating used in purification protocols often omits transitional cells that may be crucial in our understanding of haematopoiesis [@wilson2015; @kent2009; @zhang2005; @nestorowa2016]. Recently, the development of single-cell profiling techniques allowed the ability to profile transitional cells and resolve the heterogeneity within these populations at large numbers [@bendall2014; @jaitin2014; @mahata2014]. This should allow for the identification of novel HSC markers, allowing for a deeper insight into human HSC biology and facilitate further purification of HSCs for clinical applications discussed earlier [@nestorowa2016]. Here we identify *Multimerin-1* as a potential novel marker of LT-HSCs. Mmrn1 (human is abbreviated: *MMRN1*; mouse is abbreviated: *Mmrn1*) is a member of the EMILIN/Multimerin family of proteins, found in platelets, endothelial cells (EC), megakaryocytes, and the extracellular matrix (ECM) [@hayward1991; @hayward1991; @hayward1993; @hayward1995; @adam2005; @colombatti2011]. Mmrn1 is highly conserved in mammals and, importantly, murine and human orthologs are functionally very similar in spite of sequence differences (only 67% sequence similarity) [@hayward1995; @jeimy2008; @reheman2010]. It is a large polymeric, vascular adhesive protein which forms large, disulphide-linked polymers of trimers that can reach millions of Daltons in size [@hayward1991; @hayward1991; @hayward1995; @jeimy2008]. Most of the literature surrounding Mmrn1 focus on its adhesive function in the ECM, mediated via its Arg-Gly-Asp motif (RGD) located at its N-terminus [@adam2005]. In addition to its adhesive functions, Mmrn1 interacts with various integrin receptors through its conserved leucine zipper motif, facilitating its binding to platelet-activating receptors, platelet integrins and chemokine receptors [@jeimy2008]. These observations relate to the differential expression of *MMRN1*, observed in numerous cancers, as chemokines are known to play significant roles in tumour progression [@gay2011; @wojtukiewicz2017]. Moreover, upregulation of the *Mmrn1* gene is associated with increased risk of relapse and poor survival in acute myeloid leukaemia (AML) and breast cancer patients [@laszlo2015; @shi2017]. More recently it has also been used to distinguish leukaemia stem cells from leukaemia progenitor cells [@laszlo2015]. To date there have been many studies documenting differential expression of the MMRN1 gene in various cancers but its actual molecular mechanism is unknown [@saini2023]. We determined Mmrn1 differential expression in LT-HSCs by analysing single cell RNA-sequencing data collected by Nestorowa et al [@nestorowa2016]. By analysing over 1600 single HSPC transcriptomes (profiled into LT.HSCs, HSPCs and Progenitor cells using FACS index sorting) we have been able to explore the transcriptional landscape of early HSC differentiation. Here, we find Mmrn1 shows a significant association with the LT-HSC population and differential expression compared with the HSPC and Progenitor population making it a prime candidate for a novel marker of LT-HSCs. Further analysis via quantitative PCR validates this trend with high expression seen in the LT-HSC and MPP populations when compared with the progenitor population. Collectively, our study provides a comprehensive comparison of *Mmrn1* expression in the different bone marrow populations indicating it may be a promising candidate for a LT-HSC marker and worth further exploration.

# Results

#### **Single cell RNA sequencing of stem and progenitor cells reveals a distinct gradual change in gene expression profile as differentiation occurs.**

Previous single cell (sc)RNASeq has mapped the transcriptional landscape of mouse hematopoietic stem and progenitor cells (HSPCs), revealing nearly continuous differentiation, marked by distinct gene expression changes [@klein2015; @nestorowa2016; @trapnell2014]. This analysis included over 1600 single HSPC transcriptomes (profiled into 155 LT-HSCs, 701 HSPCs and 798 Progenitor cells using FACS index sorting). We have been able to explore the transcriptional landscape of early HSC differentiationNesterowa et al., 2016 using a sub section of this data, filtered for 280 surfaceome genes [@bausch-fluck2015].

We then conducted screening of this data and ensured the gene expression across the cells was consistent across the different cell types **([Figure_S1 - 3](#panelS1)**). Using 3D principal component analysis (PCA), we were able to reduce the high-dimensional gene expression data into few principal components [@ringnér2008]. The analysis showed distinct gene expression profiles for the LT-HSC, HSPC and Progenitor populations ([**Figure_1A**](#panel1)) and indicated differential expression of genes corresponding with the different phenotypes. To analyse this further we conducted a differential expression analysis ([**Figure_1B**](#fig-panel1)). This revealed 64 DE expressed genes between Prog vs HSPC, 41 between lthsc vs HSPC and, 78 between prog vs lthsc. Overall, we identified 101 genes which were differentially expressed; absolute log2-transformed fold change (FC) \> 1 with FDR \< 0.05 ([**Table_1**](#top-differentially-expressed-genes)). The most DE genes were Procr, Mmrn1, Esam, Cd48 and Cd34. Mmrn1, which has not been extensively studied or reported to be differentially expressed in hematopoietic stem cells (HSCs), showed one of the largest summary log2 fold changes, with expression particularly high in the LT-HSC population, suggesting a potentially novel finding. Unsupervised clustering of the 1656 cells and the top 50 differentially expressed genes showed subdivision of the cells into four main clusters ([**Figure_1C**](#fig-panel1)). Most interestingly, cluster 4 contained the majority of the LT.HSCs, which clustered with the HSPCs and is represented by genes such as Procr, Mmrn1 and Esam. Cluster 1 contained mainly Progenitors as well as HSPCs and is characterised by expression of genes such as Clec12a, sell and Itgal. Cluster 2 and 3 are both composed of mainly Progenitors and share expression of many representitve genes, but are differentiated by higher expression of several genes, including Epdr1, Emilin2 and Tfrc in cluster 3. With the combination of this hierarchical clustering, differential gene analysis and principal component analysis we were able to show the differential expression between cell types indicating a change in the transcriptional landscape during haematopoiesis.

#### **Gene expression can maps haematopoietic cell types**

Previously we have shown distinct gene expression profiles for the LT_HSC, HSPC and Progenitor populations ([**Figure_1A**](#panel1), [**Figure_S4**](#panelS4)). However, the progenitor and HSPC population can further be defined into 6 sub-populations using index sorting data based on flow cytometry markers ([**Figure_2A**](#panel2)**)**[@nestorowa2016]. We visualised the top differentially expressed genes, highlighting cells in red when log~2~ absolute expression of a select gene is higher than 3 ([**Figure_2B**](#fig-panel2)). We created two web resources: [https://plotly.com/\~Jwomersley /20.embed](https://plotly.com/~Jwomersley/20.embed) to visualise and compare 12 of the top differentially expressed genes using the 3D PCA plot ([**Figure_2A**](#panel2)) and [https://plotly.com/\~Jwomersley/29. embed](https://plotly.com/~Jwomersley/29.embed) to visualise all sub-population cell types. Our data shows that high *Mmrn1* gene expression overlaps with the LT.HSC population.

```{css}
#panel1 {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#panel1 .plotly {
  margin-bottom: -200px;  /* Adjust the negative margin to bring plots closer */
}
#fig-panel1 {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#fig-panel1 .pheatmap {
  margin-top: -500px; /* Adjust the negative margin to bring plots closer */
   margin-left: 10px; /* Specify the left margin for the plots */
    margin-right: 10px; /* Specify the right margin for the plots */
}

```

**A)**

::: {#panel1 layout-ncol="3" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r}

plot_3d_pca_Prog <- plot_3d_pca_Prog %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 25), width = 200, height = 200)

plot_3d_pca_Prog
```

```{r}
plot_3d_pca_HSPC <- plot_3d_pca_HSPC %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 25), width = 200, height = 200)

plot_3d_pca_HSPC
```

```{r}
plot_3d_pca_LT_HSC <- plot_3d_pca_LT_HSC %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 25), width = 200, height = 200)

plot_3d_pca_LT_HSC
```
:::

**B)**

::: {layout-ncol="3" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r, fig.show='hold', fig.height=7, align = "center"}

vol_lthsc_hspc 
```

```{r, fig.show='hold', fig.height=7, align = "center"}

 vol_prog_lthsc
```

```{r, fig.show='hold', fig.height=7, align = "center"}

 vol_prog_hspc 
```
:::

**C)**

::: {#fig-panel1 style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; width: 100%;"}
```{r, fig.show='hold', fig.height=5, out.width='100%', fig.width=10, fig.align='center'}

heatmap_subpopulation_clustering

```

**3D Principal Component Analysis, hierarchical clustering and volcano plots can be used to visualise change in gene expression across haemopoietic stem and progenitor cell differentiation**. (A) 3D PCA plots of cell surface protein expression profiles across LTHSC (Green), HSPC (Red) and Progenitor (Blue) cell types. The PCA was performed on normalised log2 expression data of surfacesome genes, whereby each dot represents a single cell and projected based on its surfacesome gene expression profile through the first 3 principal components (PC1, PC2 and PC3). Visualised: <https://plotly.com/~Jwomersley/27.embed>. (B) volcano plots depicting the differential expressed genes (DEGs) between progenitors and HSPCs (left panel), between LT.HSCs and HSPCs (middle panel) and between progenitors and LT.HSCs (right panel). The x-axis summarizes the log fold change (logFC) in gene expression, while the y-axis represents the negative log10 of the false discovery rate (FDR). Genes with significant differential expression are highlighted above the horizontal dashed line, indicating a FDR value below 0.05. Genes of the highest summary.logFC are highlighted and labelled. (C) Heatmap showing gene expression of the top 50 differentially expressed genes in all cells with the sub-population definitions applied. Each cell in the heatmap represents the expression level of a gene in a specific cell type. gene expression is displayed on a log2 scale from blue to red (low to high). All 1654 cells are visualised along the X axis and the top 50 differentially expressed genes are shown on the Y axis, as calculated using a statistical model which finds the summary.logFC. Both the genes and cells were clustered using the ward method and cut at 4 clusters.
:::

<br> <br> <br> <br>

::: {#top-differentially-expressed-genes}
```{r top-genes-table, echo=FALSE}
#| fig.align: "right"
#| fig.width: 30
#| fig.height: 7

# I am now visualising the table for our render 

# Selecting the top 20 genes for display
top_20_genes <- top_differentially_expressed_genes_no_duplicates %>%
  slice_head(n = 20)

# Generating a static table with kable from the knitr package
knitr::kable(top_20_genes,
             align = 'c', # Center align the columns
             col.names = c("p.value", "FDR", "summary.logFC", "external_gene_name", "comparison", "Prog", "HSPC", "LT_HSC"),
             format = "html", # Output the table in HTML format; use "markdown" for Markdown format
             table.attr = "style='width:100%;' class='table table-bordered table-hover'") %>%
  kableExtra::kable_styling(full_width = F, position = "center", font_size = 12)

```
:::

::: {style="color: grey"}
**Table 1: Top 20 Differentially expressed genes**. The differentially expressed genes are defined by a differential gene analysis. FDR corresponds to false discovery rate using the Benjamini-Hochberg procedure. Due to the multiple comparisons problem in gene expression analysis (testing many genes), the p-value is adjusted to control the false discovery rate, which is the expected proportion of false positives. Summary.logFC corresponds to the log fold change which is the measure of the difference in expression levels of a gene between two of the three cell-types. Higher Summary.logFC values indicate a higher level of differential expression. Note negative and positive high numbers both correspond with a high level of differential expression - this just corresponds to the swing in expression whereby negative numbers correspond to higher expression in the second cell type in the comparison. The data was also filtered to only show comparisons with a P.value \< 0.05.
:::

<br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>

```{css}
  #panel2, #fig-panel2 {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around; /* This manages spacing around items */
    align-items: center;
    width: 100%;
  }

#panel2 .plotly, #fig-panel2 .plotly {
    margin-bottom: -250px; /* Adjust the negative margin to bring plots closer */
    margin-left: 10px; /* Specify the left margin for the plots */
    margin-right: 10px; /* Specify the right margin for the plots */
    flex: 1; /* Allow plots to grow to fill space */
    max-width: calc(33.333% - 15px); /* Calculate width, subtracting margins */
  }
```

**A)**

::: {#panel2 layout-ncol="3" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; width: 100%;"}
```{r, align = "center", out.width='100%'}
PCA_sub_population <- PCA_sub_population %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

PCA_sub_population
```

```{r, align = "center", out.width='100%'}
plot_3d_pca_CMP <- plot_3d_pca_CMP %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

plot_3d_pca_CMP
```

```{r, align = "center", out.width='100%'}
plot_3d_pca_GMP <- plot_3d_pca_GMP %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

plot_3d_pca_GMP
```

```{r, align = "center", out.width='100%'}
plot_3d_pca_LMPP <- plot_3d_pca_LMPP %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

plot_3d_pca_LMPP
```

```{r, align = "center", out.width='100%'}
plot_3d_pca_MEP <- plot_3d_pca_MEP %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

plot_3d_pca_MEP
```

```{r, align = "center", out.width='100%'}
plot_3d_pca_MPP <- plot_3d_pca_MPP %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

plot_3d_pca_MPP
```
:::

**B)**

::: {#fig-panel2 layout-ncol="3" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; width: 100%;"}
```{r, align = "center", out.width='100%'}
  plot_3d_pca_Procr <- plot_3d_pca_Procr %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

  plot_3d_pca_Procr
```

```{r, align = "center", out.width='100%'}
  plot_3d_pca_mmrn1 <- plot_3d_pca_mmrn1 %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

  plot_3d_pca_mmrn1
```

```{r, align = "center", out.width='100%'}
  plot_3d_pca_ESAM <- plot_3d_pca_ESAM %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

  plot_3d_pca_ESAM
```

```{r, align="center", out.width='100%'}
  plot_3d_pca_Cd48 <- plot_3d_pca_Cd48 %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

  plot_3d_pca_Cd48
```

```{r, align = "center", out.width='100%'}
  plot_3d_pca_Cd34 <- plot_3d_pca_Cd34 %>%
  layout(margin = list(l = 0, r = 0, b = 0, t = 35), width = 200, height = 210)

  plot_3d_pca_Cd34
```

**3D principle component analysis used to visualise gene expression of top differential expressed surfacesome genes**. (A) 3D PCA analysis showing difference in gene expression between sub population cell types. Sub population cell types defined using flow cytometry markers using broad gating and identified retrospectively by using index sorting data [@nestorowa2016]. (B) 3D PCA analysis showing cells highlighted with high expression of the top 12 differentially expressed genes. Cells are highlighted in red when absolute expression of that gene is greater than 3.0. interactive version of sub-populations: <https://plotly.com/~Jwomersley/29.embed>. Interactive version looking at the 12 top differentially expressed genes: <https://plotly.com/~Jwomersley/20.embed>.
:::

<br> <br> <br> <br> <br> <br>

#### **Mmrn1 has high expression in the LT.HSC and in MPP populations.**

To Quantify hypothesis, we averaged expression of mmrn1 in the LT-HSC, HSPC and progenitor populations.  This analysis demonstrated that LT-HSCs had significantly high average Mmrn1 expression compared to the HSPC and Progenitor populations ([**Figure_3A)**](#panel3), aligning with the gene expression profiles previously shown in our PCA ([**Figure_2A-B**](#fig-panel2)). As previously stated, the progenitor and HSPC population can be further divided into 6 sub-populations. Correspondingly, Averaging Mmrn1 expression across the sub-populations confirmed its high expression remained within the LT-HSC and MPP populations ([**Figure_3B**](#panel3)). The MPP population itself can be subdivided into MPP1, MPP2, MPP3, and a generic MPP category for cells outside the more specific gating parameters. This subdivision reveals substantial variability in mmrn1 expression across the subtypes ([**Figure_3C**](#panel3)). MPP1 and the generic MPP populations maintained high expression levels, with MPP3 showing a marked decrease. These findings coincide with our principal component analysis where MPP1 closely paralleled the LT-HSC profile, followed by the generic MPP, MPP2, and MPP3 in descending order of similarity ([**Figure_2B**](#fig-panel2)). Moreover, previous hierarchical clustering placed Mmrn1 in cluster 4 alongside the MPP and LT-HSC populations ([**Figure_1C**](#fig-panel1)), underscoring its potential novel marker of long-term repopulating cells.

#### ***Mmrn1*** **Aligns with *Procr* in Marking Long-Term Hematopoietic Stem Cells.**

Hierarchical clustering revealed that Mmrn1 is closely aligned with Procr, a known marker of long-term repopulating cells ([**Figure_1C**](#fig-panel1)). Further comparison using 3D PCA demonstrated that Mmrn1 and Procr are similarly expressed across the entire population of cells, with high expression of Mmrn1 and Procr represented by yellow and low by dark blue. Quantitative analysis showed Procr and Mmrn1 exhibiting comparable expression levels across the various sub-populations, including ESLAM cells ([**Figure_3E**](#fig-panel3)). Expression being non-significantly different in all cells, except LMPPs (P = 0.0392). The expression of Slamf1, a marker used alongside Procr for isolating ESLAM cells, did not match that of Procr or Mmrn1. While its differences with Procr and Mmrn1 were non-significant in CMPs and GMPs, Slamf1 expression was significantly lower in MPPs and LT-HSCs. The most prominent finding we elucidated was Mmrn1 expression was comparable to Procr levels in the ESLAM cells. This high level of expression in cells commonly used for HSC purification underscores Mmrn1's overlap with Procr expression, reinforcing its potential use as a novel marker for LT-HSCs.

#### **Quantitative PCR confirms observations of Mmrn1 differential expression.**

We have shown (sc)RNASeq analysis of haemopoietic stem and progenitor populations revealed *mmrn1* to be highly and specifically expressed in the LT.HSC and MPP population when compared to progenitors. quantitative PCR analysis further supported these findings. we analysed cDNA for LT.HSC, MPP and progenitor cells and found increased *Mmrn1* levels in LT-HSC and MPP population relative to those of progenitors ([**Figure_3F**](#fig-panel3)). Although, the differences in expression did not reach statistical significance, suggesting the need for further investigation to fully elucidate this trend.

# discussion**:**

#### Importance of a novel marker of HSCs:

The ex vivo expansion of HSCs has been a major goal in stem cell biology, with implications in the ability to produce limitless populations of mature blood populations. There has been a major push toward purifying cells with increasing stem cell potential, such as LT.HSCs. Major breakthroughs have been achieved with near to 900-fold ex vivo expansion [@wilkinson2019]. But there is considerable heterogeneity in the self-renewal capacity of these HSCs and the identity of those that confer Long term repopulating potential following *ex vivo* HSC expansion remains elusive [@chen2019; @psatha2017]. Here we utilise molecular profiling techniques that have provided a single-cell resolution map of stem cell differentiation with the goal to identify a novel marker of LT.HSCs [@nestorowa2016].

#### **MMRN1 Expression and Its Association with HSC Subtypes:**

Here, we report high *mmrn1* expression within the LT.HSC and MPP populations. We found that *mmrn1* had higher expression in the MPP1 population than the other MPP populations. MPP1 is seen to have a multiple-lineage reconstitution ability (up to 4 months) unlike MPP2 and MPP3 which lack self-renewal potential (reviewed in [@cheng2020]). Moreover, MPP1 cells are frequently incorporated as part of the HSC population due to their identical SLAM marker expression (CD48^−^CD150^+^) but higher expression of CD34 [@oguro2013; @pietras2015; @wilkinson2019]. This highlights that *mmrn1* has a strong association with cells that have multiple-lineage reconstitution ability.

<br> <br> <br> <br> <br> <br> <br>

```{css}

#panel3_1 {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#panel3_1 .plotly {
  margin-bottom: -200px;  /* Adjust the negative margin to bring plots closer */
}

```

::: {#panel3 layout-ncol="3" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r, echo=FALSE, message=FALSE, fig.align='center'}

Mmrn1_expression_plot
```

```{r, echo=FALSE, message=FALSE, fig.align='center'}

Mmrn1_subpop_plot
```

```{r, echo=FALSE, message=FALSE, fig.align='center'}

Mmrn1_subpop_MPP_plot
```
:::

::: {#panel3_1 layout-ncol="2" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r, echo=FALSE, message=FALSE, fig.align='right'}


plot_3D_PCA_mmrn1 <- plot_3D_PCA_mmrn1_data %>%
  add_trace(x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', mode = 'markers',
            marker = list(size = 3, color = ~Expression, colorscale = 'Viridis', showscale = FALSE)) %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
    title = list(
    text = "D)                  Mmrn1",
    x = 0.05,  # Adjust this value to move the title further to the left
    y = 0.95,   # Adjust this value to change the vertical position of the title
    xanchor = "left",  # Anchor the title to the left
    yanchor = "top",   # Anchor the title to the top
    font = list(size = 22, color = "black", weight = "bolder")
    ),
    showlegend = FALSE,  # No legend displayed
    margin = list(l = 0, r = 0, b = 10, t = 30),  # Custom margins (top margin increased for title)
    width = 400,  # Set width of the plot
    height = 300  # Set height of the plot
  )

plot_3D_PCA_mmrn1
```

```{r, echo=FALSE, message=FALSE, fig.align='center'}

# Update the plot code to incorporate the gene expression colors as a gradient
plot_3D_PCA_Procr <- plot_3D_PCA_Procr_data %>%
  add_trace(x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', mode = 'markers',
            marker = list(size = 3, color = ~Expression, colorscale = 'Viridis', showscale = FALSE)) %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      yaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE),
      zaxis = list(title = "", showticklabels = FALSE, showbackground = FALSE)
    ),
    title = list(
    text = "Procr",
    x = 0.5,  # Adjust this value to move the title further to the left
    y = 0.95,   # Adjust this value to change the vertical position of the title
    xanchor = "left",  # Anchor the title to the left
    yanchor = "top",   # Anchor the title to the top
    font = list(size = 22, color = "black", weight = "bolder")
 ),
    showlegend = FALSE,  # No legend displayed
    margin = list(l = 0, r = 0, b = 10, t = 30),  # Custom margins (top margin increased for title)
    width = 400,  # Set width of the plot
    height = 300  # Set height of the plot
  )


plot_3D_PCA_Procr
```
:::

::: {#fig-panel3 layout-ncol="2" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r, echo=FALSE, message=FALSE, fig.align='center'}

ESLAM_mmrn1_plot
```

```{r, echo=FALSE, message=FALSE, fig.align='center'}

qPCR_plot
```

**Mmrn1 is highly expressed in LT.HSCs and MPP1s and follows a similar gene expression profile as Procr**.(A) average expression of Mmrn1 across LT.HSC, HSPC and Progenitor populations as determined using single cell RNA sequencing of 1,654 individual cells (155 LT.HSCs, 701 HSPCs, 798 Progs).(B) average expression of Mmrn1 using the same single cell RNA sequencing data seen in (A) but redefining the 3 cell types (LT.HSC, HSPC, Prog) into 6 sub-populations (CMP, GMP, LMPP, LT.HSC, MEP, MPP) as defined using flow cytometry markers and broad gating defined In the Nesterowa et al paper [@nestorowa2016]. (C) analysis of average gene expression of Mmrn1 using the same single cell RNA sequencing data seen in (A) but only visualising LTHSCs and redefining the MPP population further to MPP1, MPP2 and MPP3 where by any cells that has not been able to be further refined are still considered generic MPPs. (D) 3D PCA plots show gene expression levels of mmrn1 and Procr. The PCA was performed on normalised log2 expression data of surfacesome genes. Each dot represents a single cell and projected based on its surfacesome gene expression profile through the first three principle components (PC1, PC2 and PC3). Colours from yellow to blue indicates high to low expression of Mmrn1 (left 3D PCA) and Procr (right 3D PCA) showing high similarity with both. Mmrn1 plot can be visualised using this URL: <https://plotly.com/~Jwomersley/33.embed> and the Procr plot can be visualised: <https://plotly.com/~Jwomersley/31.embed>. (E) comparison of average expression of Mmrn1, Procr and CD150 genes using the same single cell RNA sequencing data seen in (A). The expression of all 3 genes was compared against the 7 cell types using retrospectively using index-sorting data provided by Nesterowa et al. The addition of ESLAM cells was incorporated by redefining cells within the original data set using Nesterowa et al's matrix of cell type information which defines further subpopulations of cells based on the flow cytometry markers. Note these cells were defined by EPCR+CD48--CD150+ because CD45 was not available in the index data. (F) quantitative PCR analysis of Mmrn1 expression across the progenitor, MPP and LT.HSC population. Results are representative of one experiment and shown as mean +/- SEM. n = 4-5 mice. \*, P \< 0.05; \*\*, P \< 0.01; \*\*\*, P \< 0.001; \*\*\*\*, P \< 0.0001.
:::

<br> <br> <br> <br> <br> <br> <br> <br>

#### **MMRN1 and Procr Expression Profiles:**

*Procr*, like that of *mmrn1*, also shows a strong association with the LT.HSC and MPP populations. We found that *mmrn1* and *Procr* showed very similar expression profiles across the CMP, GMP, LT.HSC, MEP, MPP and ESLAM population of cells. Indeed, it's been established that MPP1 contains a higher level of EPCR+ cells compared to the more lineage-biased MPP2--4 [@lin2023]. EPCR has been used for many years to identifies haemopoietic stem cells within murine bone marrow, and has been used alongside other markers to extract ESLAM cells to enrich the HSC population for long-term multilineage reconstitution [@balazs2006; @iwasaki2010; @zhou2016; @fares2017; @subramaniam2019; @papa2020; @anjos-afonso2022; @rix2022; @lin2023]. More recently, EPCR has been used alongside CD34 to isolate HSCs In humans with high repopulating and self-renewal abilities, with a stem cell frequency of \~1 in 3 cells [@anjos-afonso2022]. In fact, it's been suggested that EPCR+ cells represent the purest HSC population in humans thus far. The fact that *mmrn1* expression maps that of *procr* is why we believe MMRN1 is a very promising candidate for a novel marker of LT.HSCs, potentially for both mouse and human.

#### **MMRN1 Use as Prognostic Cancer Marker:**

*MMRN1* has been implicated as a differentially expressed gene in many cancers. It's been found to be upregulated in ovarian cancer and AML, among others [@laszlo2015; @shi2017; @elmenshawy2023; @saini2023; @zhou; @posner2022]. Most recently it is being used within the LSC17 score, which uses a sparse regression analysis of LSC gene expression against survival in a large training cohort of AML patients. This generated a powerful tool to identify AML patients who do not benefit from standard therapy and those who should be enrolled in trials [@ng2016]. This study utilised microarray data from many different sources and, like our own study, calculated an average log~2~FC value, but between LSCs and LPCs. In fact, *MMRN1* was the fourth highest weighted gene within the scoring system. Most interestingly, *CD34* was also used within the LSC17 score but weighted less than *MMRN1.* Therefore, we can suggest *MMRN1* may be a more definitive marker of cells with high self-renewal capacity, within cancer in humans, than even *CD34.*

#### **Biological Functions and Implications for HSC Isolation:**

Mmrn1 has been implicated in platelet, neutrophil and EC adhesion via binding to integrins such as αvβ3 and αIIbβ3 and been found extensively within the ECM [@adam2005; @jeimy2008]. Yet, its biological function is still poorly understood. We know that the metastasis and cancer progression is driven by cancer cells' ability to pass through the ECM and access the circulation [@poltavets2018; @friedl2008; @gritsenko2012]. Indeed, within ovarian cancer (OC), MMRN1 has been found to help with OC cancers cells adhesive functions as *MMRN1* knockdown cells showed a significant reduction in their ability to adhere to the ECM, invade and migrate [@saini2023]. Additionally, within leukaemia, MMRN1 has been assumed to have a major role in the bone marrow matrix due to its upregulation and association with relapse of disease [@laszlo2015; @elmenshawy2023]. Its even been suggested, due to its ability to form large multimers, to have a large role in the cytoarchitectural and serve as an ECM to mediate cellular attachment through the binding of ECM proteins and integrin receptors [@adam2005; @jeimy2008; @laszlo2015].

We have shown that *mmrn1* is associated with long term repopulating cells (LT.HSCs, MPP1) in healthy bone marrow, indicating its functions may extend beyond cancer. Indeed, recent studies have shown that pathways classically associated with cancer also seem to regulate normal stem cell development [@passegué2003]. We suggest higher MMRN1 expression in AML may correlate with its pronounced expression in LSCs due to our findings of *mmrn1's* association with stemness. Previously, this may have been overlooked as volunteers from Laszlo et al. had relatively low expression of *MMRN1* in their healthy bone marrow (0.170 \[range: 0.094--0.232\], n=4) [@laszlo2015]. However, we could assume that this is due to the scarcity of HSCs in healthy bone marrow (1 in 10^6^ cells) compared to the relatively larger proportion of leukaemia stem cells in cancerous bone marrow ( 1 in 1000 cells) [@wang1997; @velten2021]. Future studies should evaluate *MMRN1* and LSC levels in AML of different severities to potentially correlate *MMRN1* with worse prognosis on the basis of higher LSC's present.

#### **Future Directions and Challenges:**

One of the major complications regarding *mmrn1's* use as a novel marker of LT.HSCs is the fact it is not know to be found on the surface of cells directly. Modern strategies for extracting specific cell types utilise flow cytometry with antibodies against markers found on their surface (reviewed in [@rix2022]). However, flow cytometry has been able to determine ECM proteins association with integrins on specific cell types. indeed, it has been used to find that von Willebrand factor, which are known to mark megakaryocyte lineage piased [@sorvillo2016]. Like mmrn1, Von Willebrand factor (vWF) is a glycoprotein stored in granules, endothelial cells and platelets [@hayward1991; @hayward1991; @hayward1993; @hayward1995; @adam2005; @colombatti2011; @kent2009]. This shows that other similar proteins to mmrn1 can be found to be associated with specific haemopoietic cells though the use of flow cytometry. However, this was an in vitro study and the complexity of the extracellular matrix may impact the ability to determine mmrn1's association with HSCs, specifically with mmrn1 being heavy glycosylated and forming large multimers. Additionally, there is no knowledge of what integrins mmrn1 binds too on LT.HSCs which need to be determined. Subsequent research should determine the specific integrin profiles on LT.HSCs to which Mmrn1 binds and assess the feasibility of flow cytometry as a reliable method for detecting Mmrn1-integrin interactions on these cells.

Future studies must also determine more definitively if mmrn1 can be used alongside other functional markers of HSCs, with serial transplantation assays used to evaluate long term repopulation potential of cells extracted. Moreover, it would be important to determine mmrn1's co-localisation within the bone marrow matrix to see if it has an association with the endosteal region and more specifically close to the endosteum where LT.HSCs are found [@locelso2009]. Together, these investigations will not only provide us more of an understanding of mmrn1's role within the bone marrow matrix, but also the potential of Mmrn1 as a novel marker for LT.HSCs and its efficacy in isolating cells with robust long-term repopulation potential.

### References

::: {#refs}
:::

# Supplemental

## files

[Surfaceome_Prog.html](https://joewomersley.github.io/REPORT/data_raw/HTML/surfaceome_prog.html)

[Surfaceome_hspc.html](https://joewomersley.github.io/REPORT/data_raw/HTML/surfaceome_hspc.html)

[Surfaceome_lthsc.html](https://joewomersley.github.io/REPORT/data_raw/HTML/surfaceome_lthsc.html)

[lthsc_hspc.html](https://joewomersley.github.io/REPORT/comparisons/HTML/lthsc_hspc.html)

[prog_hspc.html](https://joewomersley.github.io/REPORT/comparisons/HTML/prog_hspc.html)

[prog_lthsc.html](https://joewomersley.github.io/REPORT/comparisons/HTML/prog_lthsc.html)

[Prog_summary_gene.html](https://joewomersley.github.io/REPORT/processed_data/HTML/prog_summary_gene.html "hspc_summary_gene.html")

[hspc_summary_gene.html](https://joewomersley.github.io/REPORT/processed_data/HTML/hspc_summary_gene.html "hspc_summary_gene.html")

[lthsc_summary_gene.html](https://joewomersley.github.io/REPORT/processed_data/HTML/lthsc_summary_gene.html "hspc_summary_gene.html")

[Prog_summary_samp.html](https://joewomersley.github.io/REPORT/processed_data/HTML/prog_summary_samp.html "hspc_summary_gene.html")

[hspc_summary_samp.html](https://joewomersley.github.io/REPORT/processed_data/HTML/hspc_summary_samp.html "hspc_summary_gene.html")

[lthsc_summary_samp.html](https://joewomersley.github.io/REPORT/processed_data/HTML/lthsc_summary_samp.html "hspc_summary_gene.html")

[qPCR_raw_data.html](https://joewomersley.github.io/REPORT/qPCR_data/HTML/qPCR_raw_data.html)

[dt_lthsc_hspc_results_sig0.01.html](https://joewomersley.github.io/REPORT/results/HTML/dt_lthsc_hspc_results_sig0.01.html "dt_lthsc_hspc_results_sig0.01.html")

[dt_prog_hspc_results_sig0.01.html](https://joewomersley.github.io/REPORT/results/HTML/dt_prog_hspc_results_sig0.01.html "dt_prog_hspc_results_sig0.01.html")

[dt_prog_lthsc_results_sig0.01.html](https://joewomersley.github.io/REPORT/results/HTML/dt_prog_lthsc_results_sig0.01.html "dt_prog_lthsc_results_sig0.01.html")

[dt_lthsc_hspc_results_with_geneinfo_sig0.01.html](https://joewomersley.github.io/REPORT/results/HTML/dt_lthsc_hspc_results_with_geneinfo_sig0.01.html "dt_lthsc_hspc_results_with_geneinfo_sig0.01.html")

[dt_prog_hspc_results_with_geneinfo_sig0.01.html](https://joewomersley.github.io/REPORT/results/HTML/dt_prog_hspc_results_with_geneinfo_sig0.01.html "dt_prog_hspc_results_with_geneinfo_sig0.01.html")

[dt_prog_lthsc_results_with_geneinfo_sig0.01.html](https://joewomersley.github.io/REPORT/results/HTML/dt_prog_lthsc_results_with_geneinfo_sig0.01.html "dt_prog_lthsc_results_with_geneinfo_sig0.01.html")

[dt_er_cell_types.html](https://joewomersley.github.io/REPORT/sub_population_data/HTML/dt_er_cell_types.html "dt_er_cell_types.html")

::: {#panelS1 style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r}
#| fig.width: 25
#| fig.height: 7
# to allow for easy comparision of the histograms we made earlier we are rendering them next to one another. 

# here we are grouping the hspc_histogram, prog_histogram and lthsc_histogram into a panel and specificying the margin of the plot which is used in this case to allow for sufficient space under the histograms before the figure legend. An issue i came across was the figure legend rednering underneath the histograms and specifcying the margins solved this issue. 
panel_histogram <- hspc_histogram + prog_histogram + lthsc_histogram + 
  plot_layout(guides = 'collect') & 
  theme(plot.margin = margin(t = 0.4, r = 0.1, b = 0, l = 0.4, unit = "cm"))

# This code adjusts the layout of the histograms as they can render portrait or landscape. Iwanted the histograms to all be next to one another so i specified ncols being 3 if you wanted one under the other you could specificy nol = 1. the heights is again to ensure that when they redner the graphs are the correct height as without specifcying this th histograms appeared squished. 
panel_histogram <- panel_histogram + 
  plot_layout(ncol = 3, heights = c(40, 2, 2)) # Adjust 'ncol' and 'heights' as needed

panel_histogram
```

figure S1: Histogram of Gene Expression Distribution Across Samples. Each histogram represents a different cell type expression derived from single-cell RNA sequencing data. Each bar in the histogram corresponds to a range of expression levels, with the x-axis representing the log2 absolute expression of the surfaceome genes, and the y-axis representing the count of cells falling within each expression range. Data analysis as conducted in R (R Core Team 2023) with patchwork, tidyverse packages (Pedersen et al. 2023; Wickham et al. 2019)
:::

::: {#panelS2 style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r}
#| fig.width: 25
#| fig.height: 7

# again we are utilising the patchwork package to combine the plots 
panel_point_error_plot <- prog_point_error_plot + lthsc_point_error_plot + hspc_point_error_plot + 
  plot_layout(guides = 'collect') 

# Again like with the histogram panel we are specifying that the graphs be ordered next to each other and specificy the height of the panel 
panel_point_error_plot <- panel_point_error_plot + 
  plot_layout(ncol = 3, heights = c(40, 2, 2)) # Adjust 'ncol' and 'heights' as needed

panel_point_error_plot
```

Figure S2: The Variability In Gene Expression Across Cell Types. Each figure above represents the distribution of gene expression across the 3 cell types derived from the single cell RNA sequencing data with cells ordered corresponding their mean expression along the X axis and mean expression along the Y axis. Each dot represents the mean expression level of each cell, the error bars extending from each point show the range of expression values within that cell within one standard deviation. Data analysis as conducted in R (R Core Team 2023) with patchwork, tidyverse packages (Pedersen et al. 2023; Wickham et al. 2019
:::

::: {#panelS3 style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r}
#| fig.width: 25
#| fig.height: 7

# again we are utilising the patchwork package to combine the plots 
panel_point_error_plot_gene <- prog_point_error_plot_gene + lthsc_point_error_plot_gene + hspc_point_error_plot_gene + 
  plot_layout(guides = 'collect') 

# Again like with the histogram panel and cell mean expression plot we are specifying that the graphs be ordered next to each other and specificy the height of the panel 
panel_point_error_plot_gene <- panel_point_error_plot_gene + 
  plot_layout(ncol = 3, heights = c(40, 2, 2)) # Adjust 'ncol' and 'heights' as needed

panel_point_error_plot_gene
```

Figure S3: Distribution Of The Mean Expression Of Each Gene. Each figure above represents the distribution of gene expression across the 3 cell types derived from the single cell RNA sequencing data with genes ordered corresponding their mean expression along the X axis and mean expression along the Y axis. Each dot represents the mean expression level of each gene for all of the cells for that specific cell type, the error bars extending from each point show the range of expression values of that gene within one standard deviation. Data analysis was conducted in R (R Core Team 2023) with patchwork, tidyverse packages (Pedersen et al. 2023; Wickham et al. 2019)
:::

::: {#panelS4 style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r}
#| #| fig.width: 10000
#| fig.height: 7 
#| 
heatmap_celltypes
```

Figure S4: Heatmap showing gene expression of the top 20 differentially expressed genes. Each cell in the heatmap represents the expression level of a gene in a specific cell type. gene expression is displayed on a log2 scale from blue to red (low to high). All 1654 cells are visualised along the X axis and the top 20 differentially expressed genes are shown on the Y axis, as calculated using a statistical model which finds the summary.logFC which is the significance of the difference between the expression in two of the three cell types. Cells were clustered based on cell type; green being LT.HSC, red being HSPC and Progenitors being Blue. Data analysis as conducted in R (R Core Team 2023) with pheatmap and tidyverse packages (Kolde et al. 2019; Wickham et al. 2019)
:::
